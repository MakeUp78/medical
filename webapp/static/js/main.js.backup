/*
 * JavaScript principale - Gestione interfaccia e sezioni
 * Replica comportamenti dell'app desktop
 */

// Variabili globali (controllo per evitare ridichiarazioni)
if (typeof currentTool === 'undefined') var currentTool = 'selection';
if (typeof isWebcamActive === 'undefined') var isWebcamActive = false;
if (typeof currentImage === 'undefined') var currentImage = null;
if (typeof currentLandmarks === 'undefined') var currentLandmarks = [];
let scoringWeights = {
  nose: 0.30,
  mouth: 0.25,
  symmetry: 0.25,
  eye: 0.20
};

// Inizializzazione al caricamento pagina
document.addEventListener('DOMContentLoaded', function () {
  console.log('üè• Facial Analysis Web App - Inizializzazione...');

  // Verifica che Fabric.js sia caricato
  if (typeof fabric === 'undefined') {
    console.error('‚ùå Fabric.js non √® caricato!');
    return;
  }

  console.log('‚úÖ Fabric.js disponibile');

  // Inizializza componenti
  initializeSections();

  // Ritardo per assicurarsi che tutto sia caricato
  setTimeout(() => {
    initializeFabricCanvas();  // Usa Fabric.js canvas invece del canvas HTML5
    initializeFileHandlers();
    initializeKeyboardShortcuts();
  }, 100);

  // Aggiorna status iniziale
  updateStatus('Pronto - Interfaccia web caricata');
  updateBadges();

  console.log('‚úÖ Inizializzazione completata');
});

// === GESTIONE SEZIONI COLLASSABILI ===

function initializeSections() {
  // Le sezioni sono gi√† configurate nel HTML con onclick
  console.log('üìÇ Sezioni collassabili inizializzate');
}

function toggleSection(headerElement) {
  const section = headerElement.parentElement;
  const content = section.querySelector('.section-content');
  const icon = headerElement.querySelector('.icon');

  const isExpanded = section.dataset.expanded === 'true';

  if (isExpanded) {
    // Chiudi sezione
    content.style.display = 'none';
    section.dataset.expanded = 'false';
    icon.textContent = '‚ñ∫';
    console.log('üìÅ Sezione chiusa:', headerElement.querySelector('.toggle-btn').textContent);
  } else {
    // Apri sezione
    content.style.display = 'block';
    section.dataset.expanded = 'true';
    icon.textContent = '‚ñº';
    console.log('üìÇ Sezione aperta:', headerElement.querySelector('.toggle-btn').textContent);
  }
}

// === GESTIONE FILE ===

function initializeFileHandlers() {
  // Drag & Drop per il canvas
  const canvas = document.getElementById('main-canvas');

  canvas.addEventListener('dragover', function (e) {
    e.preventDefault();
    e.stopPropagation();
    canvas.style.border = '3px dashed #007bff';
  });

  canvas.addEventListener('dragleave', function (e) {
    e.preventDefault();
    e.stopPropagation();
    canvas.style.border = 'none';
  });

  canvas.addEventListener('drop', function (e) {
    e.preventDefault();
    e.stopPropagation();
    canvas.style.border = 'none';

    const files = e.dataTransfer.files;
    if (files.length > 0) {
      handleFileLoad(files[0]);
    }
  });
}

function loadImage() {
  const input = document.createElement('input');
  input.type = 'file';
  input.accept = 'image/*';
  input.onchange = function (e) {
    const file = e.target.files[0];
    if (file) {
      handleFileLoad(file);
    }
  };
  input.click();
}

function loadVideo() {
  const input = document.createElement('input');
  input.type = 'file';
  input.accept = 'video/*';
  input.onchange = function (e) {
    const file = e.target.files[0];
    if (file) {
      handleVideoLoad(file);
    }
  };
  input.click();
}

function handleFileLoad(file) {
  const reader = new FileReader();

  reader.onload = function (e) {
    const img = new Image();
    img.onload = function () {
      displayImageOnCanvas(img);
      updateStatus(`Immagine caricata: ${file.name}`);
      showToast('Immagine caricata con successo', 'success');
    };
    img.src = e.target.result;
  };

  reader.readAsDataURL(file);
}

async function handleVideoLoad(file) {
  console.log('üé• handleVideoLoad iniziato:', {
    fileName: file.name,
    fileSize: file.size,
    fileType: file.type
  });

  try {
    updateStatus('Avvio analisi video...');

    // Crea elemento video nascosto per elaborazione
    const video = document.createElement('video');
    video.muted = true;
    video.style.position = 'absolute';
    video.style.left = '-9999px';
    video.style.top = '-9999px';
    document.body.appendChild(video);

    // Carica file video
    const url = URL.createObjectURL(file);
    video.src = url;

    // Aspetta caricamento video
    await new Promise(resolve => {
      video.onloadedmetadata = resolve;
    });

    // Aspetta un po' per assicurarsi che il video sia completamente caricato
    await new Promise(resolve => setTimeout(resolve, 100));

    console.log('Video caricato:', {
      width: video.videoWidth,
      height: video.videoHeight,
      duration: video.duration
    });

    // RIUSA LE FUNZIONI DELLA WEBCAM (no duplicati!)
    openWebcamSection();
    showWebcamPreview(video); // Usa la funzione webcam esistente
    await connectWebcamWebSocket();

    // Avvia elaborazione frame video con logica semplificata
    startVideoFrameProcessing(video, file.name);

    showToast('Video in elaborazione - stesso sistema della webcam', 'success');

  } catch (error) {
    console.error('Errore analisi video:', error);
    updateStatus('Errore: Impossibile analizzare il video');
    showToast('Errore analisi video', 'error');
  }
}

function startVideoFrameProcessing(video, fileName) {
  let frameCount = 0;
  const totalFrames = Math.floor(video.duration * 5); // 5 FPS per non sovraccaricare
  
  updateStatus(`Elaborazione video: ${fileName}`);
  
  const processInterval = setInterval(() => {
    if (frameCount >= totalFrames || !webcamWebSocket || webcamWebSocket.readyState !== WebSocket.OPEN) {
      clearInterval(processInterval);
      if (webcamWebSocket && webcamWebSocket.readyState === WebSocket.OPEN) {
        requestBestFramesUpdate();
      }
      return;
    }
    
    // Aggiorna posizione video
    video.currentTime = frameCount / 5;
    
    // Cattura frame e invia tramite WebSocket (riusa funzione webcam)
    captureFrameFromVideoElement(video);
    
    // Aggiorna anteprima (riusa funzione webcam)
    updateWebcamPreview(video);
    
    frameCount++;
  }, 200); // 5 FPS
}

function captureFrameFromVideoElement(video) {
  try {
    const tempCanvas = document.createElement('canvas');
    const context = tempCanvas.getContext('2d');
    
    tempCanvas.width = video.videoWidth || 640;
    tempCanvas.height = video.videoHeight || 480;
    
    context.drawImage(video, 0, 0, tempCanvas.width, tempCanvas.height);
    
    const frameBase64 = tempCanvas.toDataURL('image/jpeg', 0.8).split(',')[1];
    
    // Riusa il protocollo WebSocket della webcam
    const frameMessage = {
      action: 'process_frame',
      frame_data: frameBase64
    };
    
    webcamWebSocket.send(JSON.stringify(frameMessage));
    
  } catch (error) {
    console.error('Errore cattura frame video:', error);
  }
}

function showVideoModeChoice(fileName) {
  return new Promise((resolve) => {
    const modal = document.createElement('div');
    modal.className = 'modal';
    modal.style.display = 'block';
    modal.innerHTML = `
      <div class="modal-content">
        <div class="modal-header">
          <h3>üé• Modalit√† Video: ${fileName}</h3>
        </div>
        <div class="modal-body">
          <p>Come vuoi analizzare questo video?</p>
          <div class="choice-buttons">
            <button class="btn btn-primary" onclick="selectMode('preview')">
              üìπ Anteprima Interattiva<br>
              <small>Guarda il video e scegli i frame da analizzare</small>
            </button>
            <button class="btn btn-success" onclick="selectMode('auto')">
              ü§ñ Analisi Automatica<br>
              <small>Trova automaticamente il miglior frame frontale</small>
            </button>
          </div>
        </div>
      </div>
    `;

    document.body.appendChild(modal);

    window.selectMode = function (mode) {
      document.body.removeChild(modal);
      delete window.selectMode;
      resolve(mode);
    };
  });
}

async function showVideoPreview(file) {
  console.log('üìπ Modalit√† anteprima video');

  // Mostra modal di anteprima
  const modal = document.getElementById('preview-modal');
  const videoContainer = document.getElementById('video-player-container');
  const video = document.getElementById('preview-video');
  const modalTitle = document.getElementById('modal-title');
  const previewInfo = document.getElementById('preview-info');

  if (!modal || !video) {
    showToast('Errore: elementi video non trovati', 'error');
    return;
  }

  // Configura modal
  modalTitle.textContent = `üìπ Anteprima: ${file.name}`;
  previewInfo.innerHTML = `
    <p><strong>File:</strong> ${file.name}</p>
    <p><strong>Dimensione:</strong> ${(file.size / 1024 / 1024).toFixed(2)} MB</p>
    <p>Usa i controlli del video per navigare e scegliere i frame da analizzare.</p>
  `;

  // Carica video
  const videoURL = URL.createObjectURL(file);
  video.src = videoURL;

  // Mostra elementi
  videoContainer.style.display = 'block';
  modal.style.display = 'block';

  // Setup controlli
  setupVideoControls(video, file);

  updateStatus(`üìπ Anteprima video: ${file.name}`);
  showToast('Video caricato in anteprima', 'success');
}

async function showVideoInMainCanvas(file) {
  console.log('üé• Caricamento video nel canvas centrale');

  try {
    // Crea elemento video nascosto per processare il video
    const video = document.createElement('video');
    video.muted = true;
    video.loop = false;
    video.style.display = 'none';
    document.body.appendChild(video);

    // Carica il file video
    const videoURL = URL.createObjectURL(file);
    video.src = videoURL;

    // Aspetta che il video sia caricato
    await new Promise((resolve, reject) => {
      video.addEventListener('loadedmetadata', resolve);
      video.addEventListener('error', reject);
    });

    console.log(`üìπ Video caricato: ${video.videoWidth}x${video.videoHeight}, durata: ${video.duration.toFixed(1)}s`);

    // Crea interfaccia video nel canvas
    createVideoInterface(video, file);

    updateStatus(`üìπ Video caricato: ${file.name} (${video.duration.toFixed(1)}s)`);
    showToast('Video caricato nel canvas', 'success');

  } catch (error) {
    console.error('‚ùå Errore caricamento video:', error);
    updateStatus(`Errore caricamento video: ${error.message}`);
    showToast(`Errore: ${error.message}`, 'error');
  }
}

function createVideoInterface(video, file) {
  // Pulisci canvas
  if (fabricCanvas) {
    fabricCanvas.clear();
  }

  // Disegna primo frame
  drawVideoFrame(video, 0);

  // Crea controlli video nella sidebar destra
  createVideoControls(video, file);

  // Salva riferimento globale
  window.currentVideo = video;
  window.currentVideoFile = file;
}

function drawVideoFrame(video, currentTime) {
  if (!fabricCanvas || !video) return;

  // Imposta tempo video
  video.currentTime = currentTime;

  video.addEventListener('seeked', function onSeeked() {
    video.removeEventListener('seeked', onSeeked);

    // Cattura frame corrente
    const canvas = document.createElement('canvas');
    canvas.width = video.videoWidth;
    canvas.height = video.videoHeight;
    const ctx = canvas.getContext('2d');
    ctx.drawImage(video, 0, 0);

    // Converti in immagine
    canvas.toBlob(blob => {
      const img = new Image();
      img.onload = function () {
        displayImageOnCanvas(img);

        // Salva frame corrente come immagine
        currentImage = img;

        // Aggiorna interfaccia
        updateVideoTimeDisplay(currentTime, video.duration);
      };
      img.src = URL.createObjectURL(blob);
    }, 'image/jpeg', 0.9);
  });
}

function createVideoControls(video, file) {
  // Trova o crea container controlli nella sidebar destra
  let controlsContainer = document.getElementById('video-controls-container');

  if (!controlsContainer) {
    controlsContainer = document.createElement('div');
    controlsContainer.id = 'video-controls-container';
    controlsContainer.className = 'video-controls-panel';

    // üîß INSERISCI PRIMA delle sezioni esistenti per non coprirle
    const rightSidebar = document.querySelector('.right-sidebar');
    const measurementsSection = document.querySelector('.measurements-section');

    if (rightSidebar && measurementsSection) {
      // Inserisci prima della sezione misurazioni
      rightSidebar.insertBefore(controlsContainer, measurementsSection);
      console.log('‚úÖ Controlli video inseriti prima delle sezioni esistenti');
    } else if (rightSidebar) {
      // Fallback: append alla fine se non trova le sezioni
      rightSidebar.appendChild(controlsContainer);
      console.log('‚ö†Ô∏è Controlli video inseriti alla fine della sidebar');
    }

    // üîç VERIFICA che le sezioni esistenti siano ancora visibili
    ensureSidebarSectionsVisible();
  }

  controlsContainer.innerHTML = `
    <div class="section">
      <div class="section-header" onclick="toggleSection(this)">
        <span class="icon">‚ñº</span>
        <span class="toggle-btn">üé¨ CONTROLLI VIDEO</span>
      </div>
      <div class="section-content" style="display: block;">
        <div class="video-info">
          <p><strong>File:</strong> ${file.name}</p>
          <p><strong>Durata:</strong> ${video.duration.toFixed(1)}s</p>
          <p><strong>Risoluzione:</strong> ${video.videoWidth}x${video.videoHeight}</p>
        </div>
        
        <div class="video-timeline">
          <input type="range" id="video-timeline" min="0" max="${video.duration}" value="0" step="0.1" class="timeline-slider">
          <div id="time-display">00:00 / ${formatTime(video.duration)}</div>
        </div>
        
        <div class="video-buttons">
          <button id="play-pause-btn" class="btn btn-primary">‚ñ∂Ô∏è Play</button>
          <button id="prev-frame-btn" class="btn btn-secondary">‚èÆÔ∏è -1s</button>
          <button id="next-frame-btn" class="btn btn-secondary">‚è≠Ô∏è +1s</button>
        </div>
        
        <div class="analysis-buttons">
          <button id="analyze-current-btn" class="btn btn-success">üéØ Analizza Frame</button>
          <button id="find-best-frame-btn" class="btn btn-info">ü§ñ Trova Miglior Frame</button>
          <button id="auto-scan-btn" class="btn btn-warning">üîç Scansione Automatica</button>
        </div>
        
        <div id="frontality-score" class="frontality-display">
          <strong>Score Frontalit√†:</strong> <span id="current-score">N/A</span>
        </div>
      </div>
    </div>
  `;

  // Setup event listeners
  setupVideoEventListeners(video);

  // ‚ú® AUTOMATIZZA: Avvia immediatamente la ricerca del miglior frame frontale
  setTimeout(() => {
    console.log('üöÄ Avvio automatico ricerca miglior frame frontale...');
    updateStatus('ü§ñ Ricerca automatica del frame pi√π frontale in corso...');
    showToast('üéØ Analisi automatica avviata', 'info');
    findBestFrontalFrame();
  }, 1000); // Attesa di 1 secondo per permettere il setup completo
}

function setupVideoEventListeners(video) {
  const timeline = document.getElementById('video-timeline');
  const playPauseBtn = document.getElementById('play-pause-btn');
  const prevFrameBtn = document.getElementById('prev-frame-btn');
  const nextFrameBtn = document.getElementById('next-frame-btn');
  const analyzeBtn = document.getElementById('analyze-current-btn');
  const findBestBtn = document.getElementById('find-best-frame-btn');
  const autoScanBtn = document.getElementById('auto-scan-btn');

  let isPlaying = false;
  let playInterval = null;

  // Timeline scrubbing
  if (timeline) {
    timeline.addEventListener('input', function () {
      const time = parseFloat(this.value);
      drawVideoFrame(video, time);
    });
  }

  // Play/Pause
  if (playPauseBtn) {
    playPauseBtn.addEventListener('click', function () {
      if (isPlaying) {
        clearInterval(playInterval);
        playInterval = null;
        isPlaying = false;
        this.innerHTML = '‚ñ∂Ô∏è Play';
      } else {
        playInterval = setInterval(() => {
          let currentTime = parseFloat(timeline.value) + 0.1;
          if (currentTime >= video.duration) {
            currentTime = video.duration;
            clearInterval(playInterval);
            playInterval = null;
            isPlaying = false;
            playPauseBtn.innerHTML = '‚ñ∂Ô∏è Play';
          }
          timeline.value = currentTime;
          drawVideoFrame(video, currentTime);
        }, 100);
        isPlaying = true;
        this.innerHTML = '‚è∏Ô∏è Pause';
      }
    });
  }

  // Frame navigation
  if (prevFrameBtn) {
    prevFrameBtn.addEventListener('click', function () {
      const currentTime = Math.max(0, parseFloat(timeline.value) - 1);
      timeline.value = currentTime;
      drawVideoFrame(video, currentTime);
    });
  }

  if (nextFrameBtn) {
    nextFrameBtn.addEventListener('click', function () {
      const currentTime = Math.min(video.duration, parseFloat(timeline.value) + 1);
      timeline.value = currentTime;
      drawVideoFrame(video, currentTime);
    });
  }

  // Analisi frame corrente
  if (analyzeBtn) {
    analyzeBtn.addEventListener('click', function () {
      analyzeCurrentVideoFrame();
    });
  }

  // Trova miglior frame
  if (findBestBtn) {
    findBestBtn.addEventListener('click', function () {
      findBestFrontalFrame();
    });
  }

  // Scansione automatica
  if (autoScanBtn) {
    autoScanBtn.addEventListener('click', function () {
      startAutomaticVideoScanning();
    });
  }
}

async function analyzeCurrentVideoFrame() {
  if (!currentImage) {
    showToast('Nessun frame da analizzare', 'warning');
    return;
  }

  try {
    updateStatus('üîç Analisi frontalit√† frame corrente tramite API...');

    // Converti currentImage in base64 e usa l'API
    const imageBase64 = convertCurrentImageToBase64();
    const analysisResult = await analyzeImageViaAPI(imageBase64);

    if (analysisResult) {
      const frontalityScore = analysisResult.frontality_score;
      const poseAngles = analysisResult.pose_angles;

      // Aggiorna display score
      const scoreDisplay = document.getElementById('current-score');
      if (scoreDisplay) {
        scoreDisplay.textContent = frontalityScore.toFixed(3);
        scoreDisplay.style.color = getFrontalityColor(frontalityScore);
      }

      // Aggiungi alla tabella debug se abbiamo un video caricato
      if (window.currentVideo) {
        const timeline = document.getElementById('video-timeline');
        const currentTime = timeline ? parseFloat(timeline.value) : 0;

        const frameData = {
          frameIndex: Math.floor(currentTime / 0.5),
          time: currentTime,
          score: frontalityScore,
          pose: poseAngles,
          landmarks: analysisResult.landmarks,
          status: getFrontalityStatus(frontalityScore)
        };

        addDebugAnalysisRow(frameData);

        // Evidenzia questa riga come frame corrente
        highlightCurrentFrameInTable(currentTime);
      }

      // Attiva landmarks se non gi√† attivi
      const landmarksBtn = document.getElementById('landmarks-btn');
      if (landmarksBtn && !landmarksBtn.classList.contains('active')) {
        landmarksBtn.classList.add('active');
        updateCanvasDisplay();
      }

      updateStatus(`Frame analizzato - Score: ${frontalityScore.toFixed(3)} | Pitch: ${poseAngles.pitch.toFixed(1)}¬∞ Yaw: ${poseAngles.yaw.toFixed(1)}¬∞ Roll: ${poseAngles.roll.toFixed(1)}¬∞`);
      showToast(`Score: ${frontalityScore.toFixed(3)} | P:${poseAngles.pitch.toFixed(1)}¬∞ Y:${poseAngles.yaw.toFixed(1)}¬∞`, 'success');

      // ‚úÖ AGGIORNA IL CANVAS DOPO L'ANALISI
      updateCanvasDisplay();
    } else {
      updateStatus('Errore nell\'analisi del frame');
      showToast('Errore durante l\'analisi', 'error');
    }
  } catch (error) {
    console.error('‚ùå Errore analisi frame:', error);
    updateStatus('Errore analisi frame');
    showToast('Errore durante l\'analisi', 'error');
  }
}

function highlightCurrentFrameInTable(currentTime) {
  const tbody = document.getElementById('debug-data');
  if (!tbody) return;

  // Rimuovi highlight corrente esistenti
  Array.from(tbody.children).forEach(row => {
    row.classList.remove('current-frame-highlight');
  });

  // Trova e evidenzia il frame corrente (con tolleranza di 0.1s)
  Array.from(tbody.children).forEach(row => {
    const frameTime = parseFloat(row.getAttribute('data-frame-time'));
    if (Math.abs(frameTime - currentTime) < 0.1) {
      row.classList.add('current-frame-highlight');
    }
  });
}

async function runAutomaticVideoAnalysis(file) {
  console.log('ü§ñ Modalit√† analisi automatica');

  updateStatus(`üîÑ Analisi automatica video: ${file.name}`);
  showToast('Analisi automatica in corso...', 'info');

  // Mostra modal di analisi
  const modal = document.getElementById('video-analysis-modal');
  const statusDiv = document.getElementById('video-analysis-status');

  if (modal && statusDiv) {
    statusDiv.innerHTML = `
      <div class="analysis-progress">
        <div class="spinner"></div>
        <p>Analizzando ${file.name}...</p>
        <p>Ricerca del miglior frame frontale...</p>
      </div>
    `;
    modal.style.display = 'block';
  }

  // Continua con l'analisi automatica esistente (tutto il codice che c'era prima)
  try {
    // Prepara FormData per upload
    const formData = new FormData();
    formData.append('file', file);

    console.log('üì§ Invio video al backend...');

    // Chiama API backend per analisi video
    const response = await fetch(`${API_CONFIG.baseURL}/api/analyze-video`, {
      method: 'POST',
      body: formData
    });

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({ detail: 'Errore sconosciuto' }));
      throw new Error(`Errore API: ${errorData.detail || response.statusText}`);
    }

    const result = await response.json();
    console.log('‚úÖ Analisi video completata:', {
      success: result.success,
      score: result.score,
      totalFrames: result.total_frames,
      analyzedFrames: result.analyzed_frames
    });

    if (result.success && result.best_frame) {
      // Continua con la logica esistente per caricare il frame...
      const img = new Image();
      img.onload = async function () {
        // Chiudi modal di analisi
        if (modal) {
          modal.style.display = 'none';
        }

        // Carica il miglior frame sul canvas principale
        displayImageOnCanvas(img);

        // üîß ASSICURA che le sezioni sidebar rimangano visibili
        ensureSidebarSectionsVisible();

        if (result.landmarks && result.landmarks.length > 0) {
          currentLandmarks = result.landmarks;
          console.log('üíæ Salvati', result.landmarks.length, 'landmarks pre-analizzati dal video');
        } else {
          console.log('üîç Rilevamento landmarks dal frame del video...');
          updateStatus(`üîç Rilevamento landmarks dal frame video...`);

          try {
            await detectLandmarks();
            console.log('‚úÖ Landmarks rilevati dal frame video');
          } catch (error) {
            console.error('‚ùå Errore rilevamento landmarks:', error);
            showToast('Errore rilevamento landmarks dal frame', 'warning');
          }
        }

        // Attiva automaticamente i landmarks se disponibili
        if (currentLandmarks && currentLandmarks.length > 0) {
          const landmarksBtn = document.getElementById('landmarks-btn');
          if (landmarksBtn && !landmarksBtn.classList.contains('active')) {
            landmarksBtn.classList.add('active');
            landmarksVisible = true;
            console.log('üéØ Landmarks attivati automaticamente dopo caricamento video');
          }
        }

        updateCanvasDisplay();
        updateStatus(`Video analizzato: ${file.name} - Miglior frame (Score: ${result.score.toFixed(3)})`);
        showToast(`Video analizzato! Trovato miglior frame con score ${result.score.toFixed(3)}`, 'success');
      };

      img.src = `data:image/jpeg;base64,${result.best_frame}`;
    }

  } catch (error) {
    console.error('‚ùå Errore analisi video:', error);
    updateStatus(`Errore analisi video: ${error.message}`);
    showToast(`Errore: ${error.message}`, 'error');

    if (statusDiv) {
      statusDiv.innerHTML = `
        <div class="analysis-error">
          <h4>‚ùå Errore Analisi</h4>
          <p>${error.message}</p>
          <button onclick="closeVideoAnalysis()" class="btn btn-secondary">Chiudi</button>
        </div>
      `;
    }
  }
}

async function runAutomaticVideoAnalysisActual(file) {
  try {
    // Prepara FormData per upload
    const formData = new FormData();
    formData.append('file', file);

    console.log('üì§ Invio video al backend...');

    // Chiama API backend per analisi video
    const response = await fetch(`${API_CONFIG.baseURL}/api/analyze-video`, {
      method: 'POST',
      body: formData
    });

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({ detail: 'Errore sconosciuto' }));
      throw new Error(`Errore API: ${errorData.detail || response.statusText}`);
    }

    const result = await response.json();
    console.log('‚úÖ Analisi video completata:', {
      success: result.success,
      score: result.score,
      totalFrames: result.total_frames,
      analyzedFrames: result.analyzed_frames
    });

    if (result.success && result.best_frame) {
      // Converti base64 in immagine
      const img = new Image();
      img.onload = async function () {
        // Carica il miglior frame sul canvas
        displayImageOnCanvas(img);

        // Se il video aveva landmarks preanalizzati, usali
        if (result.landmarks && result.landmarks.length > 0) {
          currentLandmarks = result.landmarks;
          console.log('üíæ Salvati', result.landmarks.length, 'landmarks pre-analizzati dal video');
        } else {
          // Altrimenti rileva landmarks dal frame risultante
          console.log('üîç Rilevamento landmarks dal frame del video...');
          updateStatus(`üîç Rilevamento landmarks dal frame video...`);

          try {
            await detectLandmarks();
            console.log('‚úÖ Landmarks rilevati dal frame video');
          } catch (error) {
            console.error('‚ùå Errore rilevamento landmarks:', error);
            showToast('Errore rilevamento landmarks dal frame', 'warning');
          }
        }

        // Attiva automaticamente i landmarks se disponibili
        if (currentLandmarks && currentLandmarks.length > 0) {
          // Attiva il pulsante landmarks
          const landmarksBtn = document.getElementById('landmarks-btn');
          if (landmarksBtn && !landmarksBtn.classList.contains('active')) {
            landmarksBtn.classList.add('active');
            landmarksVisible = true;
            console.log('üéØ Landmarks attivati automaticamente dopo caricamento video');
          }
        }

        // Aggiorna interfaccia
        updateCanvasDisplay();
        updateStatus(`Video analizzato: ${file.name} - Miglior frame (Score: ${result.score.toFixed(3)})`);
        showToast(`Video analizzato! Trovato miglior frame con score ${result.score.toFixed(3)}`, 'success');

        // Chiudi modal
        if (modal) {
          modal.style.display = 'none';
        }

        // Mostra statistiche
        if (statusDiv) {
          statusDiv.innerHTML = `
            <div class="analysis-complete">
              <h4>‚úÖ Analisi Completata</h4>
              <p><strong>Frame totali:</strong> ${result.total_frames}</p>
              <p><strong>Frame analizzati:</strong> ${result.analyzed_frames}</p>
              <p><strong>Miglior score:</strong> ${result.score.toFixed(3)}</p>
              <p><strong>Landmarks rilevati:</strong> ${result.landmarks.length}</p>
            </div>
          `;

          // Chiudi automaticamente dopo 3 secondi
          setTimeout(() => {
            if (modal) modal.style.display = 'none';
          }, 3000);
        }
      };

      img.onerror = function () {
        throw new Error('Errore caricamento frame risultante');
      };

      img.src = `data:image/jpeg;base64,${result.best_frame}`;

    } else {
      throw new Error(result.message || 'Nessun frame valido trovato nel video');
    }

  } catch (error) {
    console.error('‚ùå Errore analisi video:', error);
    updateStatus(`Errore analisi video: ${error.message}`);
    showToast(`Errore: ${error.message}`, 'error');

    // Aggiorna modal con errore
    if (statusDiv) {
      statusDiv.innerHTML = `
        <div class="analysis-error">
          <h4>‚ùå Errore Analisi</h4>
          <p>${error.message}</p>
          <button onclick="document.getElementById('video-preview-modal').style.display='none'" class="btn btn-secondary">Chiudi</button>
        </div>
      `;
    }
  }
}

function setupVideoControls(video, file) {
  const analyzeCurrentBtn = document.getElementById('analyze-current-frame');
  const autoAnalyzeBtn = document.getElementById('auto-analyze');
  const stopBtn = document.getElementById('stop-analysis');

  // Analizza frame corrente
  if (analyzeCurrentBtn) {
    analyzeCurrentBtn.onclick = async function () {
      const currentTime = video.currentTime;
      console.log(`üéØ Analisi frame al tempo: ${currentTime}s`);

      try {
        // Cattura il frame corrente
        const canvas = document.createElement('canvas');
        canvas.width = video.videoWidth;
        canvas.height = video.videoHeight;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(video, 0, 0);

        // Converti in blob
        canvas.toBlob(async (blob) => {
          const img = new Image();
          img.onload = function () {
            // Chiudi modal di anteprima
            closeVideoPreview();

            // Carica sul canvas principale
            displayImageOnCanvas(img);

            // üîß ASSICURA che le sezioni sidebar rimangano visibili
            ensureSidebarSectionsVisible();

            // Rileva landmarks
            detectLandmarks().then(() => {
              updateCanvasDisplay();
              showToast(`Frame analizzato (${currentTime.toFixed(1)}s)`, 'success');
            });
          };

          img.src = URL.createObjectURL(blob);
        }, 'image/jpeg', 0.9);

      } catch (error) {
        console.error('‚ùå Errore cattura frame:', error);
        showToast('Errore cattura frame corrente', 'error');
      }
    };
  }

  // Analisi automatica
  if (autoAnalyzeBtn) {
    autoAnalyzeBtn.onclick = function () {
      closeVideoPreview();
      runAutomaticVideoAnalysis(file);
    };
  }
}

function closeVideoPreview() {
  const modal = document.getElementById('preview-modal');
  const video = document.getElementById('preview-video');

  if (video && video.src) {
    URL.revokeObjectURL(video.src);
    video.src = '';
  }

  if (modal) {
    modal.style.display = 'none';
  }
}

function closeVideoAnalysis() {
  const modal = document.getElementById('video-analysis-modal');
  if (modal) {
    modal.style.display = 'none';
  }
}

// === GESTIONE CANVAS ===

function initializeCanvas() {
  const canvas = document.getElementById('main-canvas');
  const ctx = canvas.getContext('2d');

  // Ridimensiona canvas al container
  resizeCanvas();
  window.addEventListener('resize', resizeCanvas);

  // Event listeners per interazioni
  canvas.addEventListener('mousedown', onCanvasMouseDown);
  canvas.addEventListener('mousemove', onCanvasMouseMove);
  canvas.addEventListener('mouseup', onCanvasMouseUp);
  canvas.addEventListener('wheel', onCanvasWheel);
  canvas.addEventListener('contextmenu', onCanvasRightClick);

  console.log('üé® Canvas inizializzato');
}

function resizeCanvas() {
  const canvas = document.getElementById('main-canvas');
  const wrapper = canvas.parentElement;

  // Salva le dimensioni correnti per evitare ridisegni inutili
  const newWidth = wrapper.clientWidth;
  const newHeight = wrapper.clientHeight;

  // Verifica che le dimensioni siano ragionevoli (max 2000px)
  if (newWidth > 2000 || newHeight > 2000 || newWidth < 10 || newHeight < 10) {
    console.warn(`‚ö†Ô∏è Dimensioni canvas anomale: ${newWidth}x${newHeight}, ignorata`);
    return;
  }

  if (canvas.width !== newWidth || canvas.height !== newHeight) {
    console.log(`üìê Ridimensionamento canvas: ${newWidth}x${newHeight}`);

    // Imposta dimensioni interne del canvas
    canvas.width = newWidth;
    canvas.height = newHeight;

    // Ridisegna solo se non siamo gi√† in un processo di disegno
    if (currentImage && !window.isDrawing) {
      window.isDrawing = true;
      displayImageOnCanvas(currentImage);
      window.isDrawing = false;
    }
  }
}

function displayImageOnCanvas(image) {
  // Usa Fabric.js invece del context 2D per evitare conflitti
  if (!fabricCanvas) {
    console.warn('‚ö†Ô∏è Fabric canvas non inizializzato');
    return;
  }

  // Rimuovi immagine precedente
  const existingImage = fabricCanvas.getObjects().find(obj => obj.isBackgroundImage);
  if (existingImage) {
    fabricCanvas.remove(existingImage);
  }

  // Calcola dimensioni mantenendo aspect ratio
  const canvasWidth = fabricCanvas.width;
  const canvasHeight = fabricCanvas.height;
  const scale = Math.min(canvasWidth / image.width, canvasHeight / image.height);
  const scaledWidth = image.width * scale;
  const scaledHeight = image.height * scale;
  const x = (canvasWidth - scaledWidth) / 2;
  const y = (canvasHeight - scaledHeight) / 2;

  console.log(`üñºÔ∏è Immagine: ${image.width}x${image.height}, Canvas: ${canvasWidth}x${canvasHeight}, Scale: ${scale.toFixed(3)}`);
  console.log(`üìç Posizione: (${x.toFixed(1)}, ${y.toFixed(1)}), Dimensioni: ${scaledWidth.toFixed(1)}x${scaledHeight.toFixed(1)}`);

  // Crea oggetto immagine Fabric.js
  const fabricImage = new fabric.Image(image, {
    left: x,
    top: y,
    scaleX: scale,
    scaleY: scale,
    selectable: false,
    evented: false,
    isBackgroundImage: true
  });

  // Aggiungi al canvas e porta in background
  fabricCanvas.add(fabricImage);
  fabricCanvas.sendToBack(fabricImage);
  fabricCanvas.renderAll();

  // Salva riferimento
  currentImage = image;

  // Salva le informazioni di scala per i landmarks
  window.imageScale = scale;
  window.imageOffset = { x: x, y: y };

  console.log('üìê IMPOSTAZIONI SCALA IMMAGINE:', {
    originalSize: `${image.width}x${image.height}`,
    canvasSize: `${fabricCanvas.width}x${fabricCanvas.height}`,
    scale: scale.toFixed(3),
    offset: `(${x.toFixed(1)}, ${y.toFixed(1)})`,
    fabricPosition: `left=${fabricImage.left}, top=${fabricImage.top}`,
    fabricScale: `scaleX=${fabricImage.scaleX?.toFixed(3)}, scaleY=${fabricImage.scaleY?.toFixed(3)}`
  });

  // Rileva SEMPRE i landmarks quando carichi un'immagine (come nell'app desktop)
  // Questo permette alle funzioni asse/green dots di funzionare anche se landmarks non sono visibili
  setTimeout(() => {
    detectLandmarks();
  }, 100);
}

// === GESTIONE WEBCAM ===

// Variabili globali per WebSocket
let webcamWebSocket = null;
let webcamStream = null;
let frameCounter = 0;
let captureInterval = null;

// Compatibility shim: legacy callers may call startRealTimeFaceDetection(video)
// Provide a thin wrapper that simply starts our frame capture loop.
function startRealTimeFaceDetection(video) {
  // If webcam already started via startWebcam(), startFrameCapture will be invoked
  // Otherwise start capturing frames directly (useful for legacy code paths)
  try {
    if (!isWebcamActive) {
      // Bind a temporary stream if video has srcObject
      if (video && video.srcObject) {
        webcamStream = video.srcObject;
        isWebcamActive = true;
        updateWebcamBadge(true);
      }
    }

    // Ensure websocket is connected
    if (!webcamWebSocket || webcamWebSocket.readyState !== WebSocket.OPEN) {
      connectWebcamWebSocket().catch(err => console.warn('Impossibile connettere WebSocket:', err));
    }

    startFrameCapture(video);
  } catch (e) {
    console.warn('startRealTimeFaceDetection shim error:', e);
  }
}

async function startWebcam() {
  try {
    updateStatus('Avvio webcam...');

    // Avvia stream webcam
    webcamStream = await navigator.mediaDevices.getUserMedia({
      video: {
        width: 640,
        height: 480,
        facingMode: 'user'
      }
    });

    const video = document.getElementById('webcam-video');
    video.srcObject = webcamStream;
    video.style.display = 'none';

    // Aspetta che il video sia pronto
    await new Promise(resolve => {
      video.onloadedmetadata = resolve;
    });

    // Mantieni canvas centrale visibile per mostrare i migliori frame
    const canvas = document.getElementById('main-canvas');
    canvas.style.display = 'block';

    // Apri automaticamente la sezione anteprima webcam
    openWebcamSection();

    // Mostra anteprima webcam nella colonna destra
    showWebcamPreview(video);

    // Connetti al WebSocket
    await connectWebcamWebSocket();

    isWebcamActive = true;
    updateStatus('Webcam attiva - Connessione al server...');
    updateWebcamBadge(true);

    // Avvia cattura frame
    startFrameCapture(video);

    showToast('Webcam avviata con successo', 'success');

  } catch (error) {
    console.error('Errore avvio webcam:', error);
    updateStatus('Errore: Impossibile accedere alla webcam');
    showToast('Errore accesso webcam', 'error');
  }
}

function stopWebcam() {
  try {
    // Ferma cattura frame
    if (captureInterval) {
      clearInterval(captureInterval);
      captureInterval = null;
    }

    // Ferma stream webcam
    if (webcamStream) {
      const tracks = webcamStream.getTracks();
      tracks.forEach(track => track.stop());
      webcamStream = null;
    }

    // Nascondi video e anteprima webcam
    const video = document.getElementById('webcam-video');
    video.srcObject = null;
    video.style.display = 'none';

    // Nascondi anteprima webcam nella colonna destra
    hideWebcamPreview();

    document.getElementById('main-canvas').style.display = 'block';

    // Chiudi WebSocket
    disconnectWebcamWebSocket();

    isWebcamActive = false;
    updateStatus('Webcam fermata');
    updateWebcamBadge(false);

    showToast('Webcam fermata', 'info');

  } catch (error) {
    console.error('Errore stop webcam:', error);
    showToast('Errore stop webcam', 'error');
  }
}

async function connectWebcamWebSocket() {
  try {
    // Connessione diretta al server WebSocket sulla porta 8765
    const wsUrl = 'ws://localhost:8765';

    webcamWebSocket = new WebSocket(wsUrl);

    webcamWebSocket.onopen = function () {
      console.log('üîå WebSocket connesso direttamente alla porta 8765');
      updateStatus('WebSocket connesso - Avvio sessione...');

      // Avvia sessione con protocollo corretto del server 8765
      const startMessage = {
        action: 'start_session',
        session_id: `webapp_session_${new Date().toISOString().replace(/[:.]/g, '_')}`
      };
      webcamWebSocket.send(JSON.stringify(startMessage));
    };

    webcamWebSocket.onmessage = function (event) {
      try {
        const data = JSON.parse(event.data);
        handleWebSocketMessage(data);
      } catch (error) {
        console.error('Errore parsing messaggio WebSocket:', error);
      }
    };

    webcamWebSocket.onclose = function () {
      console.log('üîå WebSocket webcam disconnesso');
      webcamWebSocket = null;
    };

    webcamWebSocket.onerror = function (error) {
      console.error('Errore WebSocket webcam:', error);
      showToast('Errore connessione server', 'error');
    };

  } catch (error) {
    console.error('Errore connessione WebSocket:', error);
    throw error;
  }
}

function disconnectWebcamWebSocket() {
  if (webcamWebSocket) {
    // Invia messaggio di stop con protocollo corretto
    const stopMessage = {
      action: 'get_results'
    };

    try {
      webcamWebSocket.send(JSON.stringify(stopMessage));
    } catch (error) {
      console.error('Errore invio messaggio stop:', error);
    }

    // Chiudi connessione dopo breve delay per ricevere risultati
    setTimeout(() => {
      if (webcamWebSocket) {
        webcamWebSocket.close();
        webcamWebSocket = null;
      }
    }, 1000);
  }
}

function startFrameCapture(video) {
  frameCounter = 0;

  // Cattura frame ogni 100ms (10 FPS)
  captureInterval = setInterval(() => {
    if (isWebcamActive && webcamWebSocket && webcamWebSocket.readyState === WebSocket.OPEN) {
      captureAndSendFrame(video);
      updateWebcamPreview(video); // Aggiorna anteprima nella colonna destra
    }
  }, 100);
}

function openWebcamSection() {
  // Trova e apri la sezione anteprima webcam
  const webcamSections = document.querySelectorAll('.section');
  webcamSections.forEach(section => {
    const btn = section.querySelector('.toggle-btn');
    if (btn && btn.textContent.includes('ANTEPRIMA WEBCAM')) {
      const content = section.querySelector('.section-content');
      const icon = section.querySelector('.icon');
      
      section.dataset.expanded = 'true';
      content.style.display = 'block';
      icon.textContent = '‚ñº';
    }
  });
}

function showWebcamPreview(video) {
  const previewCanvas = document.getElementById('webcam-preview-canvas');
  const previewInfo = document.getElementById('webcam-preview-info');
  
  if (previewCanvas && video) {
    previewCanvas.style.display = 'block';
    
    // Distingui tra webcam e video file
    if (video.src && video.src.startsWith('blob:')) {
      previewInfo.innerHTML = 'Video in elaborazione - Anteprima frame';
    } else {
      previewInfo.innerHTML = 'Webcam attiva - Anteprima in tempo reale';
    }
    
    // Inizia subito l'anteprima
    updateWebcamPreview(video);
  }
}

function hideWebcamPreview() {
  const previewCanvas = document.getElementById('webcam-preview-canvas');
  const previewInfo = document.getElementById('webcam-preview-info');
  
  if (previewCanvas) {
    previewCanvas.style.display = 'none';
    previewInfo.innerHTML = 'Anteprima webcam non attiva';
  }
}

function updateWebcamPreview(video) {
  const previewCanvas = document.getElementById('webcam-preview-canvas');
  if (!previewCanvas || !video || video.videoWidth === 0) return;

  try {
    const ctx = previewCanvas.getContext('2d');
    
    // Calcola dimensioni mantenendo aspect ratio
    const containerWidth = previewCanvas.parentElement.offsetWidth - 16;
    const aspectRatio = video.videoWidth / video.videoHeight;
    const canvasWidth = Math.min(containerWidth, 320);
    const canvasHeight = canvasWidth / aspectRatio;
    
    // Imposta dimensioni canvas
    previewCanvas.width = video.videoWidth;
    previewCanvas.height = video.videoHeight;
    previewCanvas.style.width = canvasWidth + 'px';
    previewCanvas.style.height = canvasHeight + 'px';
    
    // Disegna frame
    ctx.drawImage(video, 0, 0, video.videoWidth, video.videoHeight);
  } catch (error) {
    console.error('Errore anteprima:', error);
  }
}

function captureAndSendFrame(video) {
  try {
    // Crea canvas temporaneo per catturare frame
    const tempCanvas = document.createElement('canvas');
    const context = tempCanvas.getContext('2d');

    tempCanvas.width = video.videoWidth || 640;
    tempCanvas.height = video.videoHeight || 480;

    // Disegna frame video su canvas
    context.drawImage(video, 0, 0, tempCanvas.width, tempCanvas.height);

    // Converti in base64
    const frameBase64 = tempCanvas.toDataURL('image/jpeg', 0.8).split(',')[1];

    // Invia frame con protocollo corretto del server 8765
    const frameMessage = {
      action: 'process_frame',
      frame_data: frameBase64
    };

    webcamWebSocket.send(JSON.stringify(frameMessage));

  } catch (error) {
    console.error('Errore cattura frame:', error);
  }
}

function handleWebSocketMessage(data) {
  try {
    switch (data.action) {
      case 'session_started':
        updateStatus('Sessione avviata - Analisi in corso...');
        console.log('‚úÖ Sessione WebSocket avviata:', data);
        break;

      case 'frame_processed':
        // Frame elaborato dal server
        console.log('üì∏ Frame elaborato:', data);
        updateFrameProcessingStats(data);

        // Richiedi migliori frame ogni 3 frame elaborati per popolare la tabella pi√π velocemente
        if (data.total_frames_collected && data.total_frames_collected % 3 === 0 && data.total_frames_collected > 0) {
          requestBestFramesUpdate();
        }
        break;

      case 'results_ready':
        // Risultati finali dal server
        console.log('üìä Risultati finali ricevuti:', data);
        handleResultsReady(data);
        break;

      case 'pong':
        // Risposta al ping - ignora
        break;

      default:
        if (data.error) {
          console.error('‚ùå Errore dal server:', data.error);
          showToast(data.error, 'error');
        } else {
          console.log('üì® Messaggio WebSocket:', data);
        }
    }
  } catch (error) {
    console.error('Errore gestione messaggio WebSocket:', error);
  }
}

function requestBestFramesUpdate() {
  if (webcamWebSocket && webcamWebSocket.readyState === WebSocket.OPEN) {
    const requestMessage = {
      action: 'get_results'
    };
    webcamWebSocket.send(JSON.stringify(requestMessage));
  }
}

function updateFrameProcessingStats(data) {
  // Aggiorna statistiche elaborazione frame
  const frameInfo = document.getElementById('best-frame-info');
  if (frameInfo) {
    frameInfo.innerHTML = `
      Frame elaborati: ${data.total_frames_collected || 0}<br>
      Ultimo score: ${(data.current_score || 0).toFixed(3)}<br>
      Volti rilevati: ${data.faces_detected || 0}
    `;
  }
}

function updateBestFramesDisplay(data) {
  try {
    if (data.best_frames && data.best_frames.length > 0) {
      const bestFrame = data.best_frames[0]; // Prendi il miglior frame

      if (bestFrame.image_data) {
        // Aggiorna canvas con il miglior frame
        updateCanvasWithBestFrame(bestFrame.image_data);
      }
    }
  } catch (error) {
    console.error('Errore aggiornamento display frame:', error);
  }
}

function updateCanvasWithBestFrame(imageData) {
  try {
    const canvas = document.getElementById('main-canvas');
    const ctx = canvas.getContext('2d');

    // Mostra canvas se nascosto
    canvas.style.display = 'block';

    // Crea immagine da base64
    const img = new Image();
    img.onload = function () {
      // Ridimensiona canvas se necessario
      canvas.width = img.width;
      canvas.height = img.height;

      // Disegna immagine
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.drawImage(img, 0, 0);

      console.log('üñºÔ∏è Canvas aggiornato con miglior frame');
    };

    img.onerror = function () {
      console.error('Errore caricamento immagine frame');
    };

    // Imposta sorgente immagine
    img.src = 'data:image/jpeg;base64,' + imageData;

  } catch (error) {
    console.error('Errore aggiornamento canvas:', error);
  }
}

// Variabile globale per conservare i frame
let currentBestFrames = [];

function updateDebugTable(bestFrames) {
  try {
    const debugTableBody = document.getElementById('debug-data');
    if (!debugTableBody) return;

    // Salva i frame globalmente per il click handler
    currentBestFrames = bestFrames;

    // Pulisci tabella esistente
    debugTableBody.innerHTML = '';

    // Aggiungi righe per ogni frame
    bestFrames.forEach((frame, index) => {
      const row = document.createElement('tr');

      // Applica classe per evidenziare il miglior frame
      if (index === 0) {
        row.classList.add('best-frame-row');
      }

      // Aggiunge cursor pointer e click handler
      row.style.cursor = 'pointer';
      row.title = 'Clicca per visualizzare questo frame nel canvas principale';

      // Calcola il timestamp - usa quello del frame o l'attuale
      const frameTime = frame.timestamp ? new Date(frame.timestamp * 1000) : new Date();

      row.innerHTML = `
        <td>${String(frame.rank || index + 1).padStart(2, '0')}</td>
        <td>${frameTime.toLocaleTimeString()}</td>
        <td class="score-cell ${getScoreClass(frame.score)}">${(frame.score || 0).toFixed(3)}</td>
        <td>${(frame.yaw || 0).toFixed(2)}¬∞</td>
        <td>${(frame.pitch || 0).toFixed(2)}¬∞</td>
        <td>${(frame.roll || 0).toFixed(2)}¬∞</td>
        <td><span class="status-badge status-success">Salvato</span></td>
      `;

      // Aggiungi click handler per visualizzare il frame nel canvas
      row.addEventListener('click', function () {
        showFrameInMainCanvas(frame, index);

        // Rimuovi highlight precedente
        debugTableBody.querySelectorAll('tr').forEach(r => r.classList.remove('selected-frame'));
        // Aggiungi highlight alla riga selezionata
        row.classList.add('selected-frame');
      });

      debugTableBody.appendChild(row);
    });

    // Mostra automaticamente il miglior frame (primo della lista) nel canvas centrale
    if (bestFrames.length > 0 && bestFrames[0].image_data) {
      updateCanvasWithBestFrame(bestFrames[0].image_data);
    }

    console.log(`üìä Tabella debug aggiornata con ${bestFrames.length} frame`);

    // Scroll automatico alla tabella se abilitato
    const autoScroll = document.getElementById('auto-scroll');
    if (autoScroll && autoScroll.checked) {
      debugTableBody.scrollIntoView({ behavior: 'smooth', block: 'end' });
    }

  } catch (error) {
    console.error('Errore aggiornamento tabella debug:', error);
  }
}

function getScoreClass(score) {
  if (score >= 0.9) return 'excellent';
  if (score >= 0.8) return 'very-good';
  if (score >= 0.7) return 'good';
  return 'poor';
}

function showFrameInMainCanvas(frame, index) {
  try {
    console.log(`üñºÔ∏è Mostrando frame ${index + 1} nel canvas principale`);

    if (frame.image_data) {
      updateCanvasWithBestFrame(frame.image_data);

      // Aggiorna info frame corrente
      const frameInfo = document.getElementById('best-frame-info');
      if (frameInfo) {
        frameInfo.innerHTML = `
          Frame selezionato: #${index + 1}<br>
          Score: ${(frame.score || 0).toFixed(3)}<br>
          Pose: Y=${(frame.yaw || 0).toFixed(1)}¬∞ P=${(frame.pitch || 0).toFixed(1)}¬∞ R=${(frame.roll || 0).toFixed(1)}¬∞
        `;
      }

      showToast(`Frame ${index + 1} visualizzato nel canvas`, 'info');
    } else {
      showToast('Dati immagine non disponibili per questo frame', 'warning');
    }

  } catch (error) {
    console.error('Errore visualizzazione frame:', error);
    showToast('Errore visualizzazione frame', 'error');
  }
}

function handleResultsReady(data) {
  try {
    console.log('üìä Elaborando risultati dal server:', data);

    if (data.success && data.frames && data.frames.length > 0) {
      // Trasforma i dati dei frame nel formato atteso
      const bestFrames = data.frames.map((frame, index) => ({
        rank: frame.rank || index + 1,
        score: frame.score || 0,
        image_data: frame.data, // Base64 dell'immagine
        timestamp: Date.now() / 1000,
        yaw: 0,
        pitch: 0,
        roll: 0
      }));

      // Se sono disponibili i dati JSON dettagliati, usa quelli per pose
      if (data.json_data && data.json_data.frames) {
        data.json_data.frames.forEach((jsonFrame, index) => {
          if (index < bestFrames.length && jsonFrame.pose) {
            bestFrames[index].yaw = jsonFrame.pose.yaw || 0;
            bestFrames[index].pitch = jsonFrame.pose.pitch || 0;
            bestFrames[index].roll = jsonFrame.pose.roll || 0;
            bestFrames[index].timestamp = jsonFrame.timestamp || bestFrames[index].timestamp;
          }
        });
      }

      // Aggiorna tabella con i nuovi frame
      updateDebugTable(bestFrames);

      updateStatus(`Ricevuti ${bestFrames.length} migliori frame dal server`);

    } else {
      console.warn('Nessun frame valido nei risultati:', data);
    }

  } catch (error) {
    console.error('Errore gestione results_ready:', error);
  }
}

function handleFinalResults(data) {
  try {
    updateStatus('Analisi completata - Risultati finali disponibili');
    showToast(`Analisi completata: ${data.frames_count || 0} frame elaborati`, 'success');

    // Processa i risultati finali dal server 8765
    if (data.success && data.frames && data.frames.length > 0) {
      // Converti i frame nel formato della tabella debug
      const debugFrames = [];

      for (const frameInfo of data.frames) {
        const frameEntry = {
          image_data: frameInfo.data,
          score: frameInfo.score || 0,
          rank: frameInfo.rank || 0,
          timestamp: Date.now()
        };

        // Aggiungi dati pose dal JSON se disponibili
        if (data.json_data && data.json_data.frames && frameInfo.rank) {
          const jsonFrame = data.json_data.frames[frameInfo.rank - 1];
          if (jsonFrame && jsonFrame.pose) {
            frameEntry.yaw = jsonFrame.pose.yaw || 0;
            frameEntry.pitch = jsonFrame.pose.pitch || 0;
            frameEntry.roll = jsonFrame.pose.roll || 0;
          }
        }

        debugFrames.push(frameEntry);
      }

      // Aggiorna tabella debug
      updateDebugTable(debugFrames);

      // Mostra il miglior frame nel canvas
      if (debugFrames.length > 0 && debugFrames[0].image_data) {
        updateCanvasWithBestFrame(debugFrames[0].image_data);
      }

      // Salva i frame localmente nella cartella best_frontal_frames
      saveBestFramesLocally(debugFrames);
    }

  } catch (error) {
    console.error('Errore gestione risultati finali:', error);
  }
}

async function saveBestFramesLocally(frames) {
  try {
    // Nota: il salvataggio locale avviene automaticamente nel server WebSocket 8765
    // Qui possiamo fare una richiesta per verificare che i file siano stati salvati
    console.log(`üìÅ ${frames.length} frame dovrebbero essere salvati in best_frontal_frames/`);
  } catch (error) {
    console.error('Errore salvataggio frame:', error);
  }
}

// === GESTIONE STRUMENTI CANVAS ===

function setTool(tool) {
  currentTool = tool;

  // Aggiorna pulsanti toolbar
  document.querySelectorAll('.tool-btn').forEach(btn => {
    btn.classList.remove('active');
  });

  document.querySelector(`[data-tool="${tool}"]`).classList.add('active');

  // Aggiorna cursore
  updateCanvasCursor(tool);
  updateModeBadge(tool);

  console.log('üîß Strumento selezionato:', tool);
}

function updateCanvasCursor(tool) {
  const canvas = document.getElementById('main-canvas');

  const cursors = {
    'selection': 'default',
    'zoom-in': 'zoom-in',
    'zoom-out': 'zoom-out',
    'pan': 'move',
    'line': 'crosshair',
    'rectangle': 'crosshair',
    'circle': 'crosshair',
    'measure': 'crosshair'
  };

  canvas.style.cursor = cursors[tool] || 'default';
}

function clearCanvas() {
  const canvas = document.getElementById('main-canvas');
  const ctx = canvas.getContext('2d');

  ctx.clearRect(0, 0, canvas.width, canvas.height);

  if (currentImage) {
    displayImageOnCanvas(currentImage);
  }

  updateStatus('Canvas pulito');
}

function fitToWindow() {
  if (currentImage) {
    displayImageOnCanvas(currentImage);
    updateStatus('Immagine adattata alla finestra');
  }
}

// === EVENT HANDLERS CANVAS ===

let isDrawing = false;
let startX = 0;
let startY = 0;

function onCanvasMouseDown(e) {
  isDrawing = true;
  const rect = e.target.getBoundingClientRect();
  startX = e.clientX - rect.left;
  startY = e.clientY - rect.top;

  console.log(`Mouse down: (${startX}, ${startY}) - Tool: ${currentTool}`);
}

function onCanvasMouseMove(e) {
  const rect = e.target.getBoundingClientRect();
  const x = Math.round(e.clientX - rect.left);
  const y = Math.round(e.clientY - rect.top);

  // Aggiorna info cursore
  updateCursorInfo(x, y);

  if (isDrawing) {
    // Disegna in base allo strumento selezionato
    drawWithCurrentTool(startX, startY, x, y);
  }
}

function onCanvasMouseUp(e) {
  isDrawing = false;
  const rect = e.target.getBoundingClientRect();
  const endX = e.clientX - rect.left;
  const endY = e.clientY - rect.top;

  console.log(`Mouse up: (${endX}, ${endY})`);

  // Finalizza disegno
  finalizeDrawing(startX, startY, endX, endY);
}

function onCanvasWheel(e) {
  e.preventDefault();

  if (currentTool === 'zoom-in' || currentTool === 'zoom-out') {
    const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
    zoomCanvas(zoomFactor, e.offsetX, e.offsetY);
  }
}

function onCanvasRightClick(e) {
  e.preventDefault();
  showContextMenu(e.clientX, e.clientY);
}

function drawWithCurrentTool(startX, startY, endX, endY) {
  const canvas = document.getElementById('main-canvas');
  const ctx = canvas.getContext('2d');

  // Ripristina immagine base
  if (currentImage) {
    displayImageOnCanvas(currentImage);
  }

  // Disegna overlay temporaneo
  ctx.save();
  ctx.strokeStyle = '#007bff';
  ctx.lineWidth = 2;

  switch (currentTool) {
    case 'line':
      ctx.beginPath();
      ctx.moveTo(startX, startY);
      ctx.lineTo(endX, endY);
      ctx.stroke();
      break;

    case 'rectangle':
      const width = endX - startX;
      const height = endY - startY;
      ctx.strokeRect(startX, startY, width, height);
      break;

    case 'circle':
      const radius = Math.sqrt(Math.pow(endX - startX, 2) + Math.pow(endY - startY, 2));
      ctx.beginPath();
      ctx.arc(startX, startY, radius, 0, 2 * Math.PI);
      ctx.stroke();
      break;
  }

  ctx.restore();
}

function finalizeDrawing(startX, startY, endX, endY) {
  // Salva il disegno permanentemente
  console.log(`Disegno finalizzato: ${currentTool} da (${startX},${startY}) a (${endX},${endY})`);

  // TODO: Salvare in una lista di elementi disegnati
}

function zoomCanvas(factor, centerX, centerY) {
  // TODO: Implementare zoom
  console.log(`Zoom: ${factor} al punto (${centerX}, ${centerY})`);
}

// === GESTIONE RILEVAMENTI ===

async function detectLandmarks() {
  /**
   * Rileva i landmark facciali nell'immagine corrente usando l'API backend.
   * Replica esattamente il comportamento di canvas_app.py:detect_landmarks()
   */
  if (!currentImage) {
    showToast('Carica prima un\'immagine', 'warning');
    return;
  }

  try {
    updateStatus('üîÑ Rilevamento landmarks in corso...');

    // Pulisci overlay precedenti quando si rilevano nuovi landmarks  
    clearAllOverlays();

    // Converti l'immagine in base64 per l'API
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    canvas.width = currentImage.width;
    canvas.height = currentImage.height;
    ctx.drawImage(currentImage, 0, 0);
    const base64Image = canvas.toDataURL('image/jpeg', 0.9);

    // Chiama l'API per rilevare landmarks
    const response = await fetch('http://127.0.0.1:8001/api/analyze', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        image: base64Image
      })
    });

    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }

    const result = await response.json();

    if (result.landmarks && result.landmarks.length > 0) {
      // Verifica se i landmarks sono in formato normalizzato (0-1) o pixel
      const firstLandmark = result.landmarks[0];
      const isNormalized = firstLandmark.x <= 1.0 && firstLandmark.y <= 1.0;

      console.log('üîç FORMATO LANDMARKS RILEVATO:', {
        firstLandmark,
        isNormalized,
        imageSize: `${currentImage.width}x${currentImage.height}`
      });

      // Converti i landmarks dall'API al formato locale
      currentLandmarks = result.landmarks.map(lm => {
        let x = lm.x;
        let y = lm.y;

        // Se sono normalizzati, converti in pixel
        if (isNormalized && currentImage) {
          x = lm.x * currentImage.width;
          y = lm.y * currentImage.height;

          console.log(`üîÑ Normalizzato convertito: (${lm.x.toFixed(3)}, ${lm.y.toFixed(3)}) -> (${x.toFixed(1)}, ${y.toFixed(1)})`);
        }

        return {
          x,
          y,
          z: lm.z || 0,
          visibility: lm.visibility || 1.0
        };
      });

      console.log(`üíæ Salvati ${currentLandmarks.length} landmarks`);
      console.log('üéØ Primo landmark dopo conversione:', currentLandmarks[0]);
      console.log('üéØ Landmark centrale (naso):', currentLandmarks[33] || 'N/A');

      // Aggiorna la visualizzazione del canvas (equivale a update_canvas_display)
      updateCanvasDisplay();

      // Aggiorna status bar con score se disponibile
      const scoreText = result.score ? ` - Score: ${result.score.toFixed(3)}` : '';
      updateStatus(`Rilevati ${currentLandmarks.length} landmark${scoreText}`);
      showToast('Landmarks rilevati con successo', 'success');

    } else {
      updateStatus('Nessun volto rilevato');
      showToast('Nessun volto rilevato nell\'immagine', 'warning');
    }
  } catch (error) {
    console.error('Errore rilevamento landmarks:', error);
    updateStatus('‚ùå Errore rilevamento landmarks');
    showToast('Errore durante il rilevamento', 'error');
  }
}

function updateCanvasDisplay() {
  /**
   * Aggiorna la visualizzazione del canvas con overlay condizionali.
   * Replica il comportamento di canvas_app.py:update_canvas_display()
   */
  console.log('üîÑ updateCanvasDisplay chiamata');
  console.log('üìä Stato:', {
    hasCanvas: !!fabricCanvas,
    hasLandmarks: !!currentLandmarks,
    landmarksCount: currentLandmarks?.length || 0
  });

  if (!fabricCanvas) {
    console.error('‚ùå fabricCanvas non disponibile');
    return;
  }

  // PRIMA pulisci tutti gli overlay esistenti
  clearAllOverlays();

  // POI ridisegna SOLO gli overlay abilitati nell'interfaccia

  // Disegna landmarks SOLO se abilitati nell'interfaccia
  const landmarksBtn = document.getElementById('landmarks-btn');
  const landmarksActive = landmarksBtn && landmarksBtn.classList.contains('active');
  console.log('üéØ Landmarks:', {
    button: !!landmarksBtn,
    active: landmarksActive,
    hasData: !!currentLandmarks,
    landmarksLength: currentLandmarks?.length || 0
  });

  if (landmarksActive && currentLandmarks && currentLandmarks.length > 0) {
    console.log('üéØ Disegno landmarks MediaPipe - abilitati nell\'interfaccia');
    if (typeof window.drawMediaPipeLandmarks === 'function') {
      window.drawMediaPipeLandmarks(currentLandmarks);
    } else {
      console.error('‚ùå Funzione drawMediaPipeLandmarks non disponibile');
    }
  }

  // Disegna asse di simmetria SOLO se abilitato nell'interfaccia
  const axisBtn = document.getElementById('axis-btn');
  const axisActive = axisBtn && axisBtn.classList.contains('active');
  console.log('üìè Asse:', { button: !!axisBtn, active: axisActive, hasLandmarks: !!currentLandmarks });

  if (axisActive && currentLandmarks) {
    console.log('üéØ Disegno asse di simmetria - abilitato nell\'interfaccia');
    drawSymmetryAxis();
  }

  // Disegna green dots SOLO se abilitati nell'interfaccia
  const greenDotsBtn = document.getElementById('green-dots-btn');
  const greenDotsActive = greenDotsBtn && greenDotsBtn.classList.contains('active');
  console.log('üü¢ Green dots:', { button: !!greenDotsBtn, active: greenDotsActive, detected: !!window.greenDotsDetected });

  if (greenDotsActive && window.greenDotsDetected) {
    console.log('üéØ Disegno green dots - abilitati nell\'interfaccia');
    drawGreenDots();
  }

  // üîß ASSICURA che le sezioni sidebar rimangano sempre visibili
  ensureSidebarSectionsVisible();
}

function transformLandmarkCoordinate(landmark) {
  /**
   * Trasforma le coordinate del landmark dall'immagine originale 
   * alle coordinate scalate e centrate del canvas.
   */
  if (!window.imageScale || !window.imageOffset) {
    console.warn('‚ö†Ô∏è Informazioni di scala non disponibili, ricalcolo...');

    // Prova a ricalcolare le informazioni di scala dall'immagine corrente
    if (currentImage && fabricCanvas) {
      recalculateImageTransformation();
    }

    // Se ancora non disponibili, usa coordinate originali
    if (!window.imageScale || !window.imageOffset) {
      console.error('‚ùå Impossibile calcolare trasformazione coordinate');
      return landmark;
    }
  }

  const transformed = {
    x: landmark.x * window.imageScale + window.imageOffset.x,
    y: landmark.y * window.imageScale + window.imageOffset.y,
    z: landmark.z || 0,
    visibility: landmark.visibility || 1.0
  };

  // Debug per i primi landmarks
  if (landmark.x < 100) {  // Solo per i primi punti per non spammare
    console.log(`üîÑ Landmark trasformato: (${landmark.x.toFixed(1)}, ${landmark.y.toFixed(1)}) -> (${transformed.x.toFixed(1)}, ${transformed.y.toFixed(1)}) [scala: ${window.imageScale?.toFixed(3)}, offset: (${window.imageOffset?.x?.toFixed(1)}, ${window.imageOffset?.y?.toFixed(1)})]`);
  }

  return transformed;
}

function recalculateImageTransformation() {
  /**
   * Ricalcola le informazioni di trasformazione immagine quando necessario
   */
  if (!currentImage || !fabricCanvas) {
    console.error('‚ùå Impossibile ricalcolare: immagine o canvas mancanti');
    return;
  }

  // Trova l'oggetto immagine nel canvas
  const fabricImages = fabricCanvas.getObjects().filter(obj => obj.type === 'image');
  if (fabricImages.length === 0) {
    console.error('‚ùå Nessuna immagine trovata nel canvas');
    return;
  }

  const fabricImage = fabricImages[0]; // Prendi la prima immagine

  // Calcola scala e offset dalla fabric image
  const scaleX = fabricImage.scaleX || 1;
  const scaleY = fabricImage.scaleY || 1;
  const scale = Math.min(scaleX, scaleY); // Usa la scala minore per uniformit√†

  const x = fabricImage.left || 0;
  const y = fabricImage.top || 0;

  window.imageScale = scale;
  window.imageOffset = { x, y };

  console.log('üîÑ Trasformazione ricalcolata:', {
    scale: scale.toFixed(3),
    offset: `(${x.toFixed(1)}, ${y.toFixed(1)})`,
    fabricImage: {
      scaleX: scaleX.toFixed(3),
      scaleY: scaleY.toFixed(3),
      left: fabricImage.left,
      top: fabricImage.top
    }
  });
}

// Rendi la funzione globalmente accessibile
window.transformLandmarkCoordinate = transformLandmarkCoordinate;

function clearAllOverlays() {
  /**
   * Pulisce tutti gli overlay dal canvas (landmarks, assi, green dots).
   * Equivale alla pulizia che fa canvas_app.py prima di ridisegnare.
   */
  if (!fabricCanvas) return;

  const overlays = fabricCanvas.getObjects().filter(obj =>
    obj.isLandmark || obj.isSymmetryAxis || obj.isGreenDot || obj.isDebugPoint
  );
  overlays.forEach(overlay => fabricCanvas.remove(overlay));
  fabricCanvas.renderAll();
}

function clearLandmarks() {
  /**
   * Pulisce tutti gli overlay di landmarks dal canvas.
   * Chiamata da updateCanvasDisplay per gestire la visualizzazione condizionale.
   */
  if (fabricCanvas) {
    // Rimuovi tutti gli oggetti landmark dal canvas
    const landmarks = fabricCanvas.getObjects().filter(obj => obj.isLandmark);
    landmarks.forEach(landmark => fabricCanvas.remove(landmark));

    // Rimuovi anche asse e green dots per pulizia completa
    const axes = fabricCanvas.getObjects().filter(obj => obj.isSymmetryAxis);
    axes.forEach(axis => fabricCanvas.remove(axis));

    const dots = fabricCanvas.getObjects().filter(obj => obj.isGreenDot);
    dots.forEach(dot => fabricCanvas.remove(dot));

    fabricCanvas.renderAll();
  }
}

function drawSymmetryAxis() {
  /**
   * Disegna l'asse di simmetria replicando esattamente face_detector.py:draw_symmetry_axis()
   * Usa landmarks MediaPipe: Glabella (9) e Philtrum (164)
   */
  console.log('üìè drawSymmetryAxis chiamata');
  console.log('üìä Stato asse:', {
    hasCanvas: !!fabricCanvas,
    hasLandmarks: !!currentLandmarks,
    landmarksCount: currentLandmarks?.length || 0,
    hasEnoughLandmarks: currentLandmarks && currentLandmarks.length > 164
  });

  if (!fabricCanvas || !currentLandmarks || currentLandmarks.length <= 164) {
    console.error('‚ùå Condizioni non soddisfatte per disegnare l\'asse');
    return;
  }

  console.log('üéØ Disegno asse di simmetria usando landmarks 9 e 164');

  // Landmark MediaPipe esatti come nel face_detector.py
  const glabella = currentLandmarks[9];   // Punto superiore: glabella (tra le sopracciglia)
  const philtrum = currentLandmarks[164]; // Punto inferiore: philtrum (area naso-labbro)

  // Trasforma le coordinate per la scala e posizione dell'immagine
  const transformedGlabella = transformLandmarkCoordinate(glabella);
  const transformedPhiltrum = transformLandmarkCoordinate(philtrum);

  console.log('üìç Landmarks originali:', {
    glabella: { x: glabella.x.toFixed(1), y: glabella.y.toFixed(1) },
    philtrum: { x: philtrum.x.toFixed(1), y: philtrum.y.toFixed(1) }
  });

  console.log('üìç Landmarks trasformati:', {
    glabella: { x: transformedGlabella.x.toFixed(1), y: transformedGlabella.y.toFixed(1) },
    philtrum: { x: transformedPhiltrum.x.toFixed(1), y: transformedPhiltrum.y.toFixed(1) }
  });

  // DEBUG: Mostra visivamente i punti usati per l'asse
  const debugGlabella = new fabric.Circle({
    left: transformedGlabella.x - 3,
    top: transformedGlabella.y - 3,
    radius: 3,
    fill: '#00FF00',
    stroke: '#000000',
    strokeWidth: 1,
    selectable: false,
    evented: false,
    isDebugPoint: true
  });

  const debugPhiltrum = new fabric.Circle({
    left: transformedPhiltrum.x - 3,
    top: transformedPhiltrum.y - 3,
    radius: 3,
    fill: '#FFFF00',
    stroke: '#000000',
    strokeWidth: 1,
    selectable: false,
    evented: false,
    isDebugPoint: true
  });

  fabricCanvas.add(debugGlabella);
  fabricCanvas.add(debugPhiltrum);

  if (!glabella || !philtrum) {
    console.warn('‚ö†Ô∏è Landmarks 9 o 164 non disponibili per l\'asse');
    return;
  }

  // Calcola la direzione della linea usando le coordinate trasformate
  const dx = transformedPhiltrum.x - transformedGlabella.x;
  const dy = transformedPhiltrum.y - transformedGlabella.y;

  // Estendi la linea per tutta l'altezza del canvas (come nell'app desktop)
  const canvasHeight = fabricCanvas.getHeight();

  let topX, topY, bottomX, bottomY;

  if (Math.abs(dy) > 0.1) {
    // Calcola i punti di estensione
    // Punto in alto (y=0)
    topX = transformedGlabella.x - (transformedGlabella.y * dx / dy);
    topY = 0;

    // Punto in basso (y=canvasHeight)  
    bottomX = transformedGlabella.x + ((canvasHeight - transformedGlabella.y) * dx / dy);
    bottomY = canvasHeight;
  } else {
    // Linea verticale se dy √® troppo piccolo
    topX = bottomX = transformedGlabella.x;
    topY = 0;
    bottomY = canvasHeight;
  }

  // Crea linea asse con stile dell'app desktop
  const axisLine = new fabric.Line([topX, topY, bottomX, bottomY], {
    stroke: '#FF0000',      // Rosso come nell'app desktop
    strokeWidth: 2,
    strokeDashArray: [10, 5], // Linea tratteggiata
    selectable: false,
    evented: false,
    isSymmetryAxis: true
  });

  fabricCanvas.add(axisLine);
  fabricCanvas.renderAll();

  console.log(`üìè Asse di simmetria disegnato da (${topX.toFixed(1)}, ${topY}) a (${bottomX.toFixed(1)}, ${bottomY})`);
}

function clearSymmetryAxis() {
  if (fabricCanvas) {
    const axes = fabricCanvas.getObjects().filter(obj => obj.isSymmetryAxis);
    axes.forEach(axis => fabricCanvas.remove(axis));
    fabricCanvas.renderAll();
  }
}

function drawGreenDots() {
  /**
   * Disegna i green dots (punti chiave) per l'analisi medica.
   * Simula il comportamento di green_dots_processor.py usando landmarks chiave.
   */
  if (!fabricCanvas || !currentLandmarks || currentLandmarks.length === 0) return;

  console.log('üü¢ Disegno green dots sui punti chiave per analisi medica');

  // Punti chiave MediaPipe per analisi facciale medica
  // (contorno viso, occhi, naso, bocca, sopracciglia)
  const keyPoints = [
    // Contorno viso principale
    10, 151, 9, 8, 168, 6, 148, 152,
    // Occhi - punti principali
    33, 7, 163, 144, 145, 153, 154, 155, 133, 173, 157, 158, 159, 160, 161, 246,
    362, 398, 384, 385, 386, 387, 388, 466, 263, 249, 390, 373, 374, 380, 381, 382,
    // Naso - contorno e punta
    1, 2, 5, 4, 6, 19, 20, 94, 125, 141, 235, 236, 237, 238, 239, 240, 241, 242,
    // Bocca - contorno completo
    61, 84, 17, 314, 405, 320, 307, 375, 321, 308, 324, 318,
    78, 81, 13, 82, 312, 15, 16, 85, 179, 86, 316, 317, 18,
    // Sopracciglia 
    46, 53, 52, 51, 48, 115, 131, 134, 102, 49, 220, 305,
    276, 283, 282, 295, 285, 336, 296, 334, 293, 300, 276, 283
  ];

  // Disegna dots sui punti chiave esistenti
  let dotsDrawn = 0;
  keyPoints.forEach(pointIndex => {
    if (currentLandmarks[pointIndex]) {
      const point = currentLandmarks[pointIndex];
      const transformedPoint = transformLandmarkCoordinate(point);

      const dot = new fabric.Circle({
        left: transformedPoint.x - 2,
        top: transformedPoint.y - 2,
        radius: 2,
        fill: '#00FF00',     // Verde brillante
        stroke: '#008000',   // Verde scuro per il bordo
        strokeWidth: 0.5,
        selectable: false,
        evented: false,
        isGreenDot: true,
        landmarkIndex: pointIndex
      });

      fabricCanvas.add(dot);
      dotsDrawn++;
    }
  });

  fabricCanvas.renderAll();

  console.log(`üü¢ ${dotsDrawn} green dots disegnati sui punti chiave`);
}

function clearGreenDots() {
  if (fabricCanvas) {
    const dots = fabricCanvas.getObjects().filter(obj => obj.isGreenDot);
    dots.forEach(dot => fabricCanvas.remove(dot));
    fabricCanvas.renderAll();
  }
}

function toggleAxis() {
  /**
   * Gestisce il toggle del pulsante ASSE nella sezione RILEVAMENTI.
   * Replica esattamente canvas_app.py:toggle_asse_section()
   */
  const btn = document.getElementById('axis-btn');
  btn.classList.toggle('active');

  const isActive = btn.classList.contains('active');

  if (isActive) {
    if (!currentLandmarks) {
      // Se non ci sono landmarks, calcola l'asse automaticamente
      calculateAxis();
    } else {
      updateCanvasDisplay();
    }
  } else {
    updateCanvasDisplay();
  }

  updateStatus(isActive ? 'Asse di simmetria attivo' : 'Asse di simmetria disattivo');
}

function calculateAxis() {
  /**
   * Calcola e mostra l'asse di simmetria facciale.
   * Replica esattamente canvas_app.py:calculate_axis()
   */
  if (!currentImage) {
    showToast('Nessuna immagine caricata', 'warning');
    return;
  }

  // Prima rileva i landmarks se non esistono
  if (!currentLandmarks) {
    detectLandmarks().then(() => {
      if (currentLandmarks) {
        // Attiva la visualizzazione dell'asse
        document.getElementById('axis-btn').classList.add('active');
        updateCanvasDisplay();
        updateStatus('Asse di simmetria calcolato');
      } else {
        showToast('Impossibile rilevare landmarks per calcolare l\'asse', 'warning');
      }
    });
  } else {
    // Attiva la visualizzazione dell'asse
    document.getElementById('axis-btn').classList.add('active');
    updateCanvasDisplay();
    updateStatus('Asse di simmetria calcolato');
  }
}

function toggleLandmarks() {
  /**
   * Gestisce il toggle del pulsante LANDMARKS nella sezione RILEVAMENTI.
   * Replica esattamente canvas_app.py:toggle_landmarks_section()
   */
  console.log('üî• TOGGLE LANDMARKS CHIAMATA! üî•');

  const btn = document.getElementById('landmarks-btn');
  if (!btn) {
    console.error('‚ùå Pulsante landmarks-btn non trovato!');
    return;
  }

  btn.classList.toggle('active');
  const isActive = btn.classList.contains('active');

  // Aggiorna variabile globale - FORZA il valore
  window.landmarksVisible = isActive;
  if (typeof landmarksVisible !== 'undefined') {
    landmarksVisible = isActive;
  }

  console.log('üéØ Toggle Landmarks:', {
    active: isActive,
    visible: window.landmarksVisible,
    hasCurrentLandmarks: !!currentLandmarks,
    landmarksCount: currentLandmarks?.length || 0
  });

  if (isActive) {
    if (!currentLandmarks || currentLandmarks.length === 0) {
      // Se non ci sono landmarks, rilevali automaticamente
      console.log('üîç Rilevamento landmarks necessario');
      detectLandmarks();
    } else {
      // Se ci sono gi√†, aggiorna la visualizzazione
      console.log('‚úÖ Landmarks disponibili, aggiorno visualizzazione');
      updateCanvasDisplay();
    }
  } else {
    // Aggiorna visualizzazione (nasconde landmarks)
    console.log('‚ùå Nascondo landmarks');
    updateCanvasDisplay();
  }

  updateStatus(isActive ? 'Landmarks attivi' : 'Landmarks disattivi');
}

function toggleGreenDots() {
  /**
   * Gestisce il toggle del pulsante GREEN DOTS nella sezione RILEVAMENTI.
   * Replica esattamente canvas_app.py:toggle_green_dots_section()
   */
  const btn = document.getElementById('green-dots-btn');
  btn.classList.toggle('active');

  const isActive = btn.classList.contains('active');

  if (isActive) {
    // Se non ci sono green dots rilevati, rilevali automaticamente
    if (!window.greenDotsDetected) {
      detectGreenDots();
    } else {
      updateCanvasDisplay();
    }
  } else {
    updateCanvasDisplay();
  }

  updateStatus(isActive ? 'Green dots attivi' : 'Green dots disattivi');
}

function detectGreenDots() {
  /**
   * Rileva i puntini verdi REALI nell'immagine usando analisi colori HSV.
   * Replica esattamente canvas_app.py:detect_green_dots()
   * 
   * NOTA: Questa funzione dovrebbe analizzare i pixel verdi nell'immagine,
   * non disegnare punti sui landmarks. Per ora disabilitata fino a implementazione completa.
   */
  if (!currentImage) {
    showToast('Nessuna immagine caricata', 'warning');
    return;
  }

  try {
    updateStatus('üîÑ Rilevamento green dots in corso...');

    // TODO: Implementare il vero processore green dots
    // Dovrebbe analizzare i pixel HSV dell'immagine per trovare punti verdi reali
    // Come fa green_dots_processor.py nell'app desktop

    console.log('üü¢ Green dots: Funzione non ancora implementata completamente');
    console.log('‚ö†Ô∏è Dovrebbe analizzare pixel verdi reali, non landmarks');

    // Per ora NON impostare greenDotsDetected = true
    // window.greenDotsDetected = true;

    updateStatus('Green dots: implementazione in corso');
    showToast('Funzione green dots in sviluppo', 'info');

  } catch (error) {
    console.error('Errore rilevamento green dots:', error);
    updateStatus('‚ùå Errore rilevamento green dots');
    showToast('Errore durante il rilevamento', 'error');
  }
}

function toggleMeasureMode() {
  const btn = document.getElementById('measure-btn');
  btn.classList.toggle('active');

  const isActive = btn.classList.contains('active');

  if (isActive) {
    setTool('measure');
    updateStatus('Modalit√† misurazione attiva');
  } else {
    setTool('selection');
    updateStatus('Modalit√† misurazione disattiva');
  }
}

// === GESTIONE SHORTCUTS ===

function initializeKeyboardShortcuts() {
  document.addEventListener('keydown', function (e) {
    // Ctrl+C - Copia
    if (e.ctrlKey && e.key === 'c') {
      e.preventDefault();
      console.log('Copia (Ctrl+C)');
    }

    // Ctrl+V - Incolla
    if (e.ctrlKey && e.key === 'v') {
      e.preventDefault();
      console.log('Incolla (Ctrl+V)');
    }

    // ESC - Annulla operazione
    if (e.key === 'Escape') {
      setTool('selection');
      updateStatus('Operazione annullata');
    }

    // Spazio - Pan temporaneo
    if (e.key === ' ' && !e.repeat) {
      e.preventDefault();
      // TODO: Attivare pan temporaneo
    }
  });
}

// === UTILITIES ===

function updateCursorInfo(x, y) {
  const info = document.getElementById('cursor-info');
  if (info) {
    info.textContent = `Mouse: (${x}, ${y}) | Zoom: 100%`;
  }
}

function updateStatus(message) {
  const statusText = document.getElementById('status-text');
  if (statusText) {
    statusText.textContent = message;
  }
  console.log('üìä Status:', message);
}

function showProgress(message, percentage = 0) {
  const container = document.getElementById('progress-container');
  const bar = document.getElementById('progress-bar');
  const text = document.getElementById('progress-text');

  container.style.display = 'flex';
  bar.style.setProperty('--progress', `${percentage}%`);
  text.textContent = `${percentage}%`;

  updateStatus(message);
}

function hideProgress() {
  const container = document.getElementById('progress-container');
  container.style.display = 'none';
}

function updateBadges() {
  updateWebcamBadge(isWebcamActive);
  updateLandmarksBadge(currentLandmarks.length);
  updateQualityBadge(null);
  updateModeBadge(currentTool);
}

function updateWebcamBadge(connected) {
  const badge = document.getElementById('webcam-badge');
  if (badge) {
    badge.textContent = connected ? 'üìπ Webcam: Connessa' : 'üìπ Webcam: Disconnessa';
    badge.className = connected ? 'badge connected' : 'badge disconnected';
  }
}

function updateLandmarksBadge(count) {
  const badge = document.getElementById('landmarks-badge');
  if (badge) {
    badge.textContent = `üéØ Landmarks: ${count}`;
    badge.className = count > 0 ? 'badge connected' : 'badge disconnected';
  }
}

function updateQualityBadge(score) {
  const badge = document.getElementById('quality-badge');
  if (badge) {
    if (score === null) {
      badge.textContent = '‚≠ê Qualit√†: N/A';
      badge.className = 'badge disconnected';
    } else if (score >= 0.8) {
      badge.textContent = `‚≠ê Qualit√†: Eccellente (${score.toFixed(3)})`;
      badge.className = 'badge quality-excellent';
    } else if (score >= 0.6) {
      badge.textContent = `‚≠ê Qualit√†: Buona (${score.toFixed(3)})`;
      badge.className = 'badge quality-good';
    } else {
      badge.textContent = `‚≠ê Qualit√†: Scarsa (${score.toFixed(3)})`;
      badge.className = 'badge quality-poor';
    }
  }
}

function updateModeBadge(mode) {
  const badge = document.getElementById('mode-badge');
  if (badge) {
    const modes = {
      'selection': 'üîß Modalit√†: Selezione',
      'zoom-in': 'üîß Modalit√†: Zoom In',
      'zoom-out': 'üîß Modalit√†: Zoom Out',
      'pan': 'üîß Modalit√†: Pan',
      'line': 'üîß Modalit√†: Linea',
      'rectangle': 'üîß Modalit√†: Rettangolo',
      'circle': 'üîß Modalit√†: Cerchio',
      'measure': 'üîß Modalit√†: Misura'
    };

    badge.textContent = modes[mode] || 'üîß Modalit√†: Sconosciuta';
    badge.className = 'badge info';
  }
}

function showToast(message, type = 'info') {
  const toast = document.createElement('div');
  toast.className = `toast ${type}`;
  toast.textContent = message;

  document.body.appendChild(toast);

  // Rimuovi dopo 3 secondi
  setTimeout(() => {
    if (toast.parentNode) {
      toast.parentNode.removeChild(toast);
    }
  }, 3000);
}

function showContextMenu(x, y) {
  // TODO: Implementare menu contestuale
  console.log(`Menu contestuale richiesto a (${x}, ${y})`);
}

// === GESTIONE TABELLE DATI ===

function updateLandmarksTable(landmarks) {
  const tbody = document.getElementById('landmarks-data');
  if (!tbody) {
    console.warn('‚ö†Ô∏è Tabella landmarks non trovata');
    return;
  }

  // Pulisci tabella esistente
  tbody.innerHTML = '';

  if (!landmarks || landmarks.length === 0) {
    tbody.innerHTML = '<tr><td colspan="5">Nessun landmark rilevato</td></tr>';
    updateLandmarksBadge(0);
    // Reset variabili paginazione
    allCurrentLandmarks = [];
    currentLandmarksPage = 0;
    updateLandmarksPagination(0, 0, 10);
    return;
  }

  // üíæ Salva landmarks globalmente per paginazione
  allCurrentLandmarks = landmarks;
  currentLandmarksPage = 0;

  // üìè LIMITAZIONE: Mostra solo i primi 10 landmarks principali
  const maxLandmarksToShow = 10;
  const landmarksToShow = landmarks.slice(0, maxLandmarksToShow);
  const totalLandmarks = landmarks.length;

  // Aggiungi landmarks alla tabella (solo i primi 10)
  landmarksToShow.forEach((landmark, index) => {
    const row = tbody.insertRow();

    // Colore in base al tipo di landmark
    const color = getLandmarkColor(index);

    row.innerHTML = `
      <td><div class="color-indicator" style="background-color: ${color};"></div></td>
      <td>${index}</td>
      <td>${getLandmarkName(index)}</td>
      <td>${landmark.x ? landmark.x.toFixed(1) : 'N/A'}</td>
      <td>${landmark.y ? landmark.y.toFixed(1) : 'N/A'}</td>
    `;
  });

  // üìä Aggiungi riga informativa se ci sono pi√π di 10 landmarks
  if (totalLandmarks > maxLandmarksToShow) {
    const infoRow = tbody.insertRow();
    infoRow.className = 'landmarks-info-row';
    infoRow.innerHTML = `
      <td colspan="5" style="text-align: center; font-style: italic; color: #888; padding: 8px;">
        üìã Mostrando ${maxLandmarksToShow} di ${totalLandmarks} landmarks totali
        <br><span style="font-size: 9px;">Tutti i landmarks sono visibili sul canvas</span>
      </td>
    `;
  }

  // Aggiorna badge con il numero totale
  updateLandmarksBadge(totalLandmarks);

  console.log(`üìä Tabella landmarks aggiornata: mostrati ${landmarksToShow.length}/${totalLandmarks} punti`);

  // üìÑ Gestisci controlli paginazione
  updateLandmarksPagination(totalLandmarks, 0, maxLandmarksToShow);
}

function getLandmarkColor(index) {
  // Colori per diversi tipi di landmarks
  const colors = [
    '#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FFEAA7',
    '#DDA0DD', '#98D8C8', '#F7DC6F', '#BB8FCE', '#85C1E9',
    '#F8C471', '#82E0AA', '#F1948A', '#85C1E9', '#D7BDE2'
  ];

  return colors[index % colors.length];
}

function getLandmarkName(index) {
  // Nomi dei landmarks basati su MediaPipe Face Mesh
  const names = {
    0: 'Centro naso',
    1: 'Punta naso',
    2: 'Narice sx',
    3: 'Narice dx',
    4: 'Angolo occhio sx int',
    5: 'Angolo occhio sx est',
    6: 'Angolo occhio dx int',
    7: 'Angolo occhio dx est',
    8: 'Angolo bocca sx',
    9: 'Angolo bocca dx',
    10: 'Labbro sup centro',
    11: 'Labbro inf centro',
    12: 'Sopracciglio sx int',
    13: 'Sopracciglio sx est',
    14: 'Sopracciglio dx int',
    15: 'Sopracciglio dx est'
  };

  return names[index] || `Landmark ${index}`;
}

function clearLandmarksTable() {
  const tbody = document.getElementById('landmarks-data');
  if (tbody) {
    tbody.innerHTML = '<tr><td colspan="5">Nessun landmark rilevato</td></tr>';
  }
  updateLandmarksBadge(0);
}

// === DEBUG ANALYSIS TABLE FUNCTIONS ===
function clearDebugAnalysisTable() {
  const tbody = document.getElementById('debug-data');
  if (tbody) {
    tbody.innerHTML = '<tr><td colspan="7">Nessun dato di analisi</td></tr>';
  }
}

function addDebugAnalysisRow(frameData) {
  const tbody = document.getElementById('debug-data');
  if (!tbody) return;

  // Rimuovi placeholder se presente
  if (tbody.children.length === 1 && tbody.children[0].textContent.includes('Nessun dato')) {
    tbody.innerHTML = '';
  }

  const row = document.createElement('tr');
  row.setAttribute('data-frame-time', frameData.time);
  row.className = getRowClassByScore(frameData.score);

  // Rendi la riga cliccabile per saltare al frame
  row.style.cursor = 'pointer';
  row.onclick = () => jumpToVideoFrame(frameData.time);

  row.innerHTML = `
    <td>${frameData.frameIndex}</td>
    <td>${formatTime(frameData.time)}</td>
    <td class="score-cell" style="color: ${getFrontalityColor(frameData.score)}">${frameData.score.toFixed(3)}</td>
    <td>${frameData.pose.yaw.toFixed(1)}¬∞</td>
    <td>${frameData.pose.pitch.toFixed(1)}¬∞</td>
    <td>${frameData.pose.roll.toFixed(1)}¬∞</td>
    <td class="status-cell">${frameData.status}</td>
  `;

  tbody.appendChild(row);

  // Mantieni solo gli ultimi 50 risultati per performance
  while (tbody.children.length > 50) {
    tbody.removeChild(tbody.firstChild);
  }
}

function highlightBestFramesInTable(topResults) {
  // Rimuovi highlight esistenti
  const tbody = document.getElementById('debug-data');
  if (!tbody) return;

  Array.from(tbody.children).forEach(row => {
    row.classList.remove('best-frame-highlight', 'very-frontal-frame', 'top-frame');
  });

  // üèÜ Aggiungi highlight categorizzato per i frame migliori
  topResults.forEach((result, index) => {
    const row = tbody.querySelector(`[data-frame-time="${result.time}"]`);
    if (row) {
      // Classificazione per ranking
      if (index === 0) {
        row.classList.add('top-frame'); // Primo classificato
        row.title = `ü•á MIGLIOR FRAME - Score: ${result.score.toFixed(3)} | Pitch: ${result.pose.pitch.toFixed(1)}¬∞ Yaw: ${result.pose.yaw.toFixed(1)}¬∞`;
      } else if (index < 3) {
        row.classList.add('best-frame-highlight'); // Top 3
        row.title = `ü•à #${index + 1} Frame Frontale - Score: ${result.score.toFixed(3)} | Pitch: ${result.pose.pitch.toFixed(1)}¬∞ Yaw: ${result.pose.yaw.toFixed(1)}¬∞`;
      } else if (result.score > 0.7) {
        row.classList.add('very-frontal-frame'); // Molto frontali
        row.title = `‚≠ê #${index + 1} Frame Molto Frontale - Score: ${result.score.toFixed(3)} | Pitch: ${result.pose.pitch.toFixed(1)}¬∞ Yaw: ${result.pose.yaw.toFixed(1)}¬∞`;
      }

      // üìä Aggiungi badge ranking nella prima colonna
      const firstCell = row.querySelector('td:first-child');
      if (firstCell && index < 5) {
        const badge = index === 0 ? 'ü•á' : index === 1 ? 'ü•à' : index === 2 ? 'ü•â' : `#${index + 1}`;
        firstCell.innerHTML = `${badge} ${firstCell.textContent}`;
      }
    }
  });

  // üìà Mostra riassunto nella console
  console.log(`üèÜ TOP ${Math.min(topResults.length, 10)} FRAME FRONTALI EVIDENZIATI NELLA TABELLA:`);
  topResults.slice(0, 10).forEach((result, index) => {
    const medal = index === 0 ? 'ü•á' : index === 1 ? 'ü•à' : index === 2 ? 'ü•â' : `#${index + 1}`;
    console.log(`${medal} t=${result.time.toFixed(1)}s - Score: ${result.score.toFixed(3)} | P:${result.pose.pitch.toFixed(1)}¬∞ Y:${result.pose.yaw.toFixed(1)}¬∞ R:${result.pose.roll.toFixed(1)}¬∞`);
  });
}

// üéØ Filtri per la tabella dei frame frontali
function filterFramesByFrontality(filterType) {
  const tbody = document.getElementById('debug-data');
  if (!tbody) return;

  const rows = Array.from(tbody.children);
  let visibleCount = 0;

  rows.forEach(row => {
    if (row.textContent.includes('Nessun dato')) {
      return; // Skip placeholder row
    }

    const scoreCell = row.querySelector('.score-cell');
    if (!scoreCell) return;

    const score = parseFloat(scoreCell.textContent);
    let shouldShow = false;

    switch (filterType) {
      case 'all':
        shouldShow = true;
        break;
      case 'frontal':
        shouldShow = score > 0.7;
        break;
      case 'very-frontal':
        shouldShow = score > 0.8;
        break;
      case 'excellent':
        shouldShow = score > 0.9;
        break;
      case 'top':
        shouldShow = row.classList.contains('top-frame') ||
          row.classList.contains('best-frame-highlight') ||
          row.classList.contains('very-frontal-frame');
        break;
    }

    if (shouldShow) {
      row.style.display = '';
      visibleCount++;
    } else {
      row.style.display = 'none';
    }
  });

  // Aggiorna i pulsanti di filtro per mostrare quale √® attivo
  document.querySelectorAll('.frontal-filters .btn-mini').forEach(btn => {
    btn.classList.remove('active');
  });
  event.target.classList.add('active');

  // Mostra statistiche del filtro
  const filterNames = {
    'all': 'Tutti i frame',
    'frontal': 'Frame frontali (>0.7)',
    'very-frontal': 'Frame molto frontali (>0.8)',
    'excellent': 'Frame eccellenti (>0.9)',
    'top': 'Frame migliori evidenziati'
  };

  showToast(`üìä Filtro: ${filterNames[filterType]} - ${visibleCount} frame visibili`, 'info');
}

// üîç Funzione per assicurare che le sezioni della sidebar rimangano visibili
function ensureSidebarSectionsVisible() {
  const sectionsToCheck = [
    { selector: '.measurements-section', name: 'Misurazioni' },
    { selector: '.landmarks-section', name: 'Landmarks' },
    { selector: '.debug-section', name: 'Debug' }
  ];

  console.log('üîç Verifica visibilit√† sezioni sidebar...');

  sectionsToCheck.forEach(({ selector, name }) => {
    const section = document.querySelector(selector);
    if (section) {
      // Assicura che la sezione sia visibile
      if (section.style.display === 'none') {
        section.style.display = 'block';
        console.log(`‚úÖ Ripristinata visibilit√† sezione: ${name}`);
      }

      // Assicura che non sia nascosta da CSS
      section.style.visibility = 'visible';
      section.style.opacity = '1';

      console.log(`‚úÖ Sezione ${name} verificata e visibile`);
    } else {
      console.warn(`‚ö†Ô∏è Sezione ${name} non trovata!`);
    }
  });

  // Verifica che la sidebar non abbia problemi di layout
  const rightSidebar = document.querySelector('.right-sidebar');
  if (rightSidebar) {
    rightSidebar.style.display = 'block';
    console.log('‚úÖ Right sidebar confermata visibile');
  }
}

// üìÑ Variabili globali per paginazione landmarks
let currentLandmarksPage = 0;
const landmarksPerPage = 10;
let allCurrentLandmarks = [];

// üìÑ Funzioni per gestire la paginazione dei landmarks
function updateLandmarksPagination(totalLandmarks, currentPage, itemsPerPage) {
  const paginationDiv = document.getElementById('landmarks-pagination');
  const pageInfo = document.getElementById('landmarks-page-info');
  const prevBtn = document.getElementById('landmarks-prev');
  const nextBtn = document.getElementById('landmarks-next');

  if (totalLandmarks <= itemsPerPage) {
    // Nascondi controlli se non servono
    paginationDiv.style.display = 'none';
    return;
  }

  // Mostra controlli
  paginationDiv.style.display = 'flex';

  const totalPages = Math.ceil(totalLandmarks / itemsPerPage);
  pageInfo.textContent = `Pagina ${currentPage + 1}/${totalPages} (${totalLandmarks} landmarks)`;

  // Abilita/disabilita pulsanti
  prevBtn.disabled = currentPage === 0;
  nextBtn.disabled = currentPage >= totalPages - 1;

  prevBtn.style.opacity = prevBtn.disabled ? '0.5' : '1';
  nextBtn.style.opacity = nextBtn.disabled ? '0.5' : '1';
}

function showLandmarksPage(direction) {
  if (!allCurrentLandmarks || allCurrentLandmarks.length === 0) {
    showToast('Nessun landmark disponibile', 'warning');
    return;
  }

  const totalPages = Math.ceil(allCurrentLandmarks.length / landmarksPerPage);

  if (direction === 'next' && currentLandmarksPage < totalPages - 1) {
    currentLandmarksPage++;
  } else if (direction === 'prev' && currentLandmarksPage > 0) {
    currentLandmarksPage--;
  }

  // Aggiorna visualizzazione
  updateLandmarksTablePage(allCurrentLandmarks, currentLandmarksPage);
}

function updateLandmarksTablePage(landmarks, page) {
  const tbody = document.getElementById('landmarks-data');
  if (!tbody) return;

  // Calcola indici per la pagina corrente
  const startIndex = page * landmarksPerPage;
  const endIndex = Math.min(startIndex + landmarksPerPage, landmarks.length);
  const pageData = landmarks.slice(startIndex, endIndex);

  // Pulisci e riempi tabella
  tbody.innerHTML = '';

  pageData.forEach((landmark, relativeIndex) => {
    const absoluteIndex = startIndex + relativeIndex;
    const row = tbody.insertRow();
    const color = getLandmarkColor(absoluteIndex);

    row.innerHTML = `
      <td><div class="color-indicator" style="background-color: ${color};"></div></td>
      <td>${absoluteIndex}</td>
      <td>${getLandmarkName(absoluteIndex)}</td>
      <td>${landmark.x ? landmark.x.toFixed(1) : 'N/A'}</td>
      <td>${landmark.y ? landmark.y.toFixed(1) : 'N/A'}</td>
    `;
  });

  // Aggiorna controlli paginazione
  updateLandmarksPagination(landmarks.length, page, landmarksPerPage);

  console.log(`üìÑ Pagina landmarks ${page + 1}: mostrati ${pageData.length} di ${landmarks.length} totali`);
}

function showAllLandmarks() {
  if (!allCurrentLandmarks || allCurrentLandmarks.length === 0) {
    showToast('Nessun landmark disponibile', 'warning');
    return;
  }

  // Crea una finestra popup con tutti i landmarks
  const popup = window.open('', 'AllLandmarks', 'width=600,height=400,scrollbars=yes');

  let html = `
    <!DOCTYPE html>
    <html>
    <head>
      <title>Tutti i Landmarks (${allCurrentLandmarks.length})</title>
      <style>
        body { font-family: Arial, sans-serif; margin: 20px; background: #2a2a2a; color: white; }
        table { width: 100%; border-collapse: collapse; margin-top: 10px; }
        th, td { padding: 8px; text-align: left; border-bottom: 1px solid #555; }
        th { background: #404040; }
        tr:nth-child(even) { background: #333; }
        .color-indicator { width: 12px; height: 12px; border-radius: 50%; display: inline-block; margin-right: 5px; }
      </style>
    </head>
    <body>
      <h2>üéØ Tutti i Landmarks (${allCurrentLandmarks.length} punti)</h2>
      <table>
        <thead>
          <tr><th>üé®</th><th>ID</th><th>Nome</th><th>X</th><th>Y</th></tr>
        </thead>
        <tbody>
  `;

  allCurrentLandmarks.forEach((landmark, index) => {
    const color = getLandmarkColor(index);
    html += `
      <tr>
        <td><div class="color-indicator" style="background-color: ${color};"></div></td>
        <td>${index}</td>
        <td>${getLandmarkName(index)}</td>
        <td>${landmark.x ? landmark.x.toFixed(1) : 'N/A'}</td>
        <td>${landmark.y ? landmark.y.toFixed(1) : 'N/A'}</td>
      </tr>
    `;
  });

  html += `
        </tbody>
      </table>
    </body>
    </html>
  `;

  popup.document.write(html);
  popup.document.close();

  showToast(`üìã Finestra con tutti i ${allCurrentLandmarks.length} landmarks aperta`, 'info');
}

function jumpToVideoFrame(time) {
  if (!window.currentVideo) {
    showToast('Nessun video caricato', 'warning');
    return;
  }

  // Aggiorna timeline e salta al frame
  const timeline = document.getElementById('video-timeline');
  if (timeline) {
    timeline.value = time;
  }

  drawVideoFrame(window.currentVideo, time);
  showToast(`Saltato al frame: ${formatTime(time)}`, 'info');
}

// FUNZIONE OBSOLETA - Ora usa l'API backend con logica landmarkPredict_webcam.py
/*
async function calculateDetailedPoseAngles(landmarks) {
  // DEPRECATA: Sostituita dall'API backend che usa la logica migliorata
  // di landmarkPredict_webcam.py con calcoli PnP pi√π precisi.
  // Tutte le chiamate a questa funzione sono state sostituite con analyzeImageViaAPI()
  
  console.warn('‚ö†Ô∏è FUNZIONE OBSOLETA: calculateDetailedPoseAngles() - Usa analyzeImageViaAPI()');
  return { pitch: 0, yaw: 0, roll: 0 };
}
*/

function getFrontalityStatus(score) {
  if (score >= 0.8) return 'üü¢ OTTIMA';
  if (score >= 0.6) return 'üü° BUONA';
  if (score >= 0.4) return 'üü† MEDIA';
  return 'üî¥ SCARSA';
}

function getRowClassByScore(score) {
  if (score >= 0.8) return 'excellent-frame';
  if (score >= 0.6) return 'good-frame';
  if (score >= 0.4) return 'medium-frame';
  return 'poor-frame';
}

// === DEBUG LANDMARKS FUNCTION ===
function forceShowLandmarks() {
  console.log('üî• FORZANDO VISUALIZZAZIONE LANDMARKS üî•');

  if (!currentLandmarks || currentLandmarks.length === 0) {
    console.error('‚ùå Nessun landmark disponibile');
    return;
  }

  // Forza l'attivazione del pulsante
  const btn = document.getElementById('landmarks-btn');
  if (btn) {
    btn.classList.add('active');
    console.log('‚úÖ Pulsante landmarks attivato forzatamente');
  }

  // Forza variabili globali
  window.landmarksVisible = true;
  if (typeof landmarksVisible !== 'undefined') {
    landmarksVisible = true;
  }

  // Landmarks drawing functionality removed

  // Verifica risultato
  const landmarkObjects = fabricCanvas.getObjects().filter(obj => obj.isLandmark);
  console.log('üìä Risultato debug:', {
    totalCanvasObjects: fabricCanvas.getObjects().length,
    landmarkObjects: landmarkObjects.length,
    landmarks: landmarkObjects.slice(0, 3)
  });
}

// Funzione diagnostica completa
function diagnoseLandmarksIssue() {
  console.log('üîç === DIAGNOSI LANDMARKS === üîç');

  // Verifica DOM
  const btn = document.getElementById('landmarks-btn');
  console.log('üéõÔ∏è Pulsante landmarks:', {
    exists: !!btn,
    classes: btn?.className,
    isActive: btn?.classList.contains('active')
  });

  // Verifica variabili globali
  console.log('üìä Variabili stato:', {
    'window.landmarksVisible': window.landmarksVisible,
    'landmarksVisible': typeof landmarksVisible !== 'undefined' ? landmarksVisible : 'undefined',
    'currentLandmarks': !!currentLandmarks,
    'landmarksCount': currentLandmarks?.length || 0
  });

  // Verifica canvas
  console.log('üé® Canvas state:', {
    fabricCanvas: !!fabricCanvas,
    totalObjects: fabricCanvas?.getObjects()?.length || 0,
    landmarkObjects: fabricCanvas?.getObjects()?.filter(obj => obj.isLandmark)?.length || 0
  });

  // Landmarks functions removed

  // Test campione landmarks se disponibili
  if (currentLandmarks && currentLandmarks.length > 0) {
    console.log('üìç Sample landmarks:', currentLandmarks.slice(0, 3));
  }

  return {
    buttonActive: btn?.classList.contains('active'),
    hasLandmarks: !!currentLandmarks && currentLandmarks.length > 0,
    functionsAvailable: false, // drawLandmarksMain function removed
    canvasReady: !!fabricCanvas
  };
}

// Funzione test per landmarks con punti fissi
function testLandmarksWithFixedPoints() {
  if (!fabricCanvas) {
    console.error('‚ùå Canvas non disponibile');
    return;
  }

  // Crea landmarks di test in posizioni note
  const testLandmarks = [
    { x: 100, y: 100, z: 0, visibility: 1.0 }, // Top-left area
    { x: 200, y: 150, z: 0, visibility: 1.0 }, // Center-left  
    { x: 300, y: 200, z: 0, visibility: 1.0 }, // Center
    { x: 400, y: 150, z: 0, visibility: 1.0 }, // Center-right
    { x: 500, y: 100, z: 0, visibility: 1.0 }  // Top-right area
  ];

  console.log('üß™ TEST LANDMARKS CON PUNTI FISSI:', testLandmarks);

  // Imposta landmarks di test
  currentLandmarks = testLandmarks;

  // Forza visualizzazione
  const btn = document.getElementById('landmarks-btn');
  if (btn) btn.classList.add('active');
  window.landmarksVisible = true;

  // Landmarks drawing functionality removed

  console.log('üéØ Test landmarks completato');
}

// Funzione debug avanzata per landmarks
function debugLandmarksDetailed() {
  console.log('üîç === DEBUG LANDMARKS DETTAGLIATO ===');

  if (!currentLandmarks || currentLandmarks.length === 0) {
    console.log('‚ùå Nessun landmark disponibile');
    return;
  }

  console.log(`üìä STATISTICHE LANDMARKS:
    - Totale: ${currentLandmarks.length}
    - Formato: ${currentLandmarks[0].x > 1 ? 'Pixel' : 'Normalizzato'}
    - Range X: ${Math.min(...currentLandmarks.map(lm => lm.x)).toFixed(1)} - ${Math.max(...currentLandmarks.map(lm => lm.x)).toFixed(1)}
    - Range Y: ${Math.min(...currentLandmarks.map(lm => lm.y)).toFixed(1)} - ${Math.max(...currentLandmarks.map(lm => lm.y)).toFixed(1)}
  `);

  // Landmarks chiave MediaPipe (equivalenti ai 68 dlib)
  const keyLandmarks = [
    { index: 10, name: 'Fronte centro' },
    { index: 151, name: 'Mento' },
    { index: 33, name: 'Naso punta' },
    { index: 362, name: 'Occhio sinistro centro' },
    { index: 133, name: 'Occhio destro centro' },
    { index: 61, name: 'Labbro superiore' },
    { index: 17, name: 'Labbro inferiore' }
  ];

  console.log('üéØ LANDMARKS CHIAVE:');
  keyLandmarks.forEach(({ index, name }) => {
    if (currentLandmarks[index]) {
      const lm = currentLandmarks[index];
      console.log(`  ${name} (${index}): (${lm.x.toFixed(1)}, ${lm.y.toFixed(1)})`);
    }
  });

  // Informazioni trasformazione
  console.log(`üîÑ TRASFORMAZIONE:
    - imageScale: ${window.imageScale?.toFixed(3)}
    - imageOffset: (${window.imageOffset?.x?.toFixed(1)}, ${window.imageOffset?.y?.toFixed(1)})
    - Canvas: ${fabricCanvas?.width}x${fabricCanvas?.height}
    - Immagine: ${currentImage?.width}x${currentImage?.height}
  `);

  // Canvas objects
  const landmarkObjects = fabricCanvas?.getObjects().filter(obj => obj.isLandmark) || [];
  console.log(`üé® CANVAS: ${landmarkObjects.length} cerchi landmark disegnati`);
}

// Rendi globalmente accessibile per debug
window.forceShowLandmarks = forceShowLandmarks;
window.diagnoseLandmarksIssue = diagnoseLandmarksIssue;
window.testLandmarksWithFixedPoints = testLandmarksWithFixedPoints;
window.recalculateImageTransformation = recalculateImageTransformation;
window.debugLandmarksDetailed = debugLandmarksDetailed;

// === FACE-LANDMARK-LOCALIZATION INTEGRATION INFO ===
function showFaceLandmarkLocalizationInfo() {
  console.log(`
üß† === FACE-LANDMARK-LOCALIZATION INTEGRATION REPORT ===

üìã FUNZIONI UTILIZZATE DAL PROGETTO ORIGINALE:
  ‚úÖ calculatePoseAngles() - Adattata da landmarkPredict.py
  ‚úÖ pose_name array ['Pitch', 'Yaw', 'Roll'] - Implementato
  ‚úÖ Punti chiave 68-landmarks - Compatibile
  ‚úÖ Sistema scoring frontalit√† - Implementato

üéØ LOGICA DI CALCOLO POSE (da face-landmark-localization):
  ‚Ä¢ Tip of nose (landmark 33) - ‚úÖ Utilizzato
  ‚Ä¢ Chin (landmark 8) - ‚úÖ Utilizzato  
  ‚Ä¢ Left eye corner (landmark 36) - ‚úÖ Utilizzato
  ‚Ä¢ Right eye corner (landmark 45) - ‚úÖ Utilizzato
  ‚Ä¢ Mouth corners (landmarks 48, 54) - ‚úÖ Utilizzato

üìê CALCOLI IMPLEMENTATI:
  ‚Ä¢ YAW: Simmetria occhi + bocca rispetto centro immagine
  ‚Ä¢ PITCH: Rapporto naso-mento + posizione verticale occhi  
  ‚Ä¢ ROLL: Inclinazione linea degli occhi
  ‚Ä¢ FRONTALITY SCORE: 1.0 - ((|pitch|/90 + |yaw|/90) / 2)

üöÄ MIGLIORAMENTI WEBAPP RISPETTO ALL'ORIGINALE:
  ‚úÖ Real-time video analysis con timeline
  ‚úÖ Tabella debug con tutti i frame analizzati
  ‚úÖ Color coding per qualit√† frontalit√†
  ‚úÖ Click-to-jump nella tabella debug
  ‚úÖ Scansione automatica completa video
  ‚úÖ Sistema di ranking frame migliori

‚ö†Ô∏è  DIFFERENZE DALL'ORIGINALE:
  ‚Ä¢ Non usa Caffe/dlib (sostituiti con MediaPipe via API)
  ‚Ä¢ Non carica modelli .caffemodel (usa rilevamento web-based)  
  ‚Ä¢ Calcoli pose approssimativi (no PnP solver completo)
  ‚Ä¢ Range angoli limitati: Pitch/Yaw ¬±45¬∞, Roll ¬±30¬∞

üìä STATO ATTUALE:
  ‚Ä¢ Sistema completamente integrato e funzionante ‚úÖ
  ‚Ä¢ Compatibilit√† logica face-landmark-localization ‚úÖ
  ‚Ä¢ Interfaccia user-friendly per analisi video ‚úÖ
  `);

  return {
    functionsUsed: [
      'calculatePoseAngles()',
      'pose_name array',
      '68-landmarks system',
      'frontality scoring logic'
    ],
    improvements: [
      'Real-time video timeline',
      'Debug analysis table',
      'Automatic best frame detection',
      'Interactive frame jumping',
      'Color-coded quality indicators'
    ],
    differences: [
      'MediaPipe instead of Caffe/dlib',
      'Web-based instead of desktop Python',
      'Approximated pose calculations',
      'Limited angle ranges for stability'
    ]
  };
}

// Nuove funzioni per video nel canvas centrale
function updateVideoTimeDisplay(currentTime, duration) {
  const timeDisplay = document.getElementById('time-display');
  if (timeDisplay) {
    timeDisplay.textContent = `${formatTime(currentTime)} / ${formatTime(duration)}`;
  }
}

function formatTime(seconds) {
  const mins = Math.floor(seconds / 60);
  const secs = Math.floor(seconds % 60);
  return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
}

/**
 * Converte currentImage in base64 per l'invio all'API
 */
function convertCurrentImageToBase64() {
  if (!currentImage) {
    throw new Error('currentImage non disponibile');
  }

  const canvas = document.createElement('canvas');
  canvas.width = currentImage.width;
  canvas.height = currentImage.height;
  const ctx = canvas.getContext('2d');
  ctx.drawImage(currentImage, 0, 0);
  return canvas.toDataURL('image/jpeg', 0.8);
}

// FUNZIONE OBSOLETA - Ora usa l'API backend con logica landmarkPredict_webcam.py
/*
async function calculateFrontalityScore(landmarks) {
  // DEPRECATA: Sostituita dall'API backend che implementa la logica migliorata
  // di landmarkPredict_webcam.py con calcoli PnP per la posa della testa.
  // Tutte le chiamate a questa funzione sono state sostituite con analyzeImageViaAPI()
  
  console.warn('‚ö†Ô∏è FUNZIONE OBSOLETA: calculateFrontalityScore() - Usa analyzeImageViaAPI()');
  return 0.0;
}
*/

// Funzione calculatePoseAngles rimossa - ora usa l'API backend con logica landmarkPredict_webcam.py

function getFrontalityColor(score) {
  if (score >= 0.8) return '#00ff00'; // Verde - ottima frontalit√†
  if (score >= 0.6) return '#ffff00'; // Giallo - buona frontalit√†
  if (score >= 0.4) return '#ff8800'; // Arancione - media frontalit√†
  return '#ff0000'; // Rosso - scarsa frontalit√†
}

async function findBestFrontalFrame() {
  if (!window.currentVideo) {
    showToast('Nessun video caricato', 'warning');
    return;
  }

  const video = window.currentVideo;
  const duration = video.duration;
  const stepSize = 1.0; // Analizza ogni secondo
  let bestScore = 0;
  let bestTime = 0;
  const allResults = []; // üìä Raccoglie tutti i risultati per la tabella

  updateStatus('üîç Ricerca del miglior frame frontale...');

  try {
    // üìã Pulisci tabella prima della nuova scansione
    clearDebugAnalysisTable();

    for (let time = 0; time < duration; time += stepSize) {
      // Aggiorna progress
      const progress = (time / duration) * 100;
      updateStatus(`üîç Scansione: ${progress.toFixed(1)}% (${time.toFixed(1)}s/${duration.toFixed(1)}s)`);

      // Salta al frame
      drawVideoFrame(video, time);
      await new Promise(resolve => setTimeout(resolve, 500)); // Pausa per rendering

      // Converti currentImage in base64 per l'API
      if (!currentImage) {
        console.warn('‚ö†Ô∏è currentImage non disponibile, salto frame');
        continue;
      }

      try {
        const imageBase64 = convertCurrentImageToBase64();
        const analysisResult = await analyzeImageViaAPI(imageBase64);

        if (analysisResult && analysisResult.frontality_score) {
          const score = analysisResult.frontality_score;
          const poseAngles = analysisResult.pose_angles;

          // üìä Aggiungi tutti i risultati alla tabella
          const frameData = {
            frameIndex: Math.floor(time / stepSize),
            time: time,
            score: score,
            pose: poseAngles,
            landmarks: analysisResult.landmarks,
            status: getFrontalityStatus(score)
          };

          allResults.push(frameData);
          addDebugAnalysisRow(frameData);

          if (score > bestScore) {
            bestScore = score;
            bestTime = time;
            console.log(`üìà Nuovo miglior frame: t=${time.toFixed(1)}s, score=${score.toFixed(3)}`);
          }
        }
      } catch (error) {
        console.warn(`‚ö†Ô∏è Errore analisi frame a ${time.toFixed(1)}s:`, error);
      }
    }

    // üéØ Ordina e evidenzia i migliori frame nella tabella
    allResults.sort((a, b) => b.score - a.score);
    const topFrames = allResults.slice(0, 10); // Top 10 frame frontali
    highlightBestFramesInTable(topFrames);

    // üìà Mostra statistiche dei frame frontali
    const frontalFrames = allResults.filter(f => f.score > 0.7); // Score > 0.7 considerato frontale
    console.log(`üìä STATISTICHE FRONTALIT√Ä:`);
    console.log(`- Frame totali analizzati: ${allResults.length}`);
    console.log(`- Frame molto frontali (>0.7): ${frontalFrames.length}`);
    console.log(`- Migliori 5 frame:`, topFrames.slice(0, 5).map(f => `t=${f.time.toFixed(1)}s (${f.score.toFixed(3)})`));

    // Vai al miglior frame trovato
    const timeline = document.getElementById('video-timeline');
    if (timeline) {
      timeline.value = bestTime;
    }
    drawVideoFrame(video, bestTime);

    // Analizza il miglior frame
    await analyzeCurrentVideoFrame();

    // ‚úÖ AGGIORNA IL CANVAS ALLA FINE DELL'ANALISI
    updateCanvasDisplay();

    // üîß ASSICURA che le sezioni sidebar rimangano visibili dopo l'analisi
    ensureSidebarSectionsVisible();

    updateStatus(`‚úÖ AUTOMATICO: Miglior frame selezionato a ${bestTime.toFixed(1)}s (Score: ${bestScore.toFixed(3)}) - ${frontalFrames.length}/${allResults.length} frame frontali trovati`);
    showToast(`üéØ Frame frontale trovato: ${bestTime.toFixed(1)}s (Score: ${bestScore.toFixed(3)}) - ${frontalFrames.length} frame molto frontali`, 'success');

  } catch (error) {
    console.error('‚ùå Errore ricerca miglior frame:', error);
    updateStatus('Errore durante la ricerca');
    showToast('Errore nella ricerca automatica', 'error');
  }
}

async function startAutomaticVideoScanning() {
  if (!window.currentVideo) {
    showToast('Nessun video caricato', 'warning');
    return;
  }

  const video = window.currentVideo;
  const duration = video.duration;
  const stepSize = 0.5; // Scansione pi√π fine ogni 0.5s
  const results = [];

  updateStatus('ü§ñ Scansione automatica completa in corso...');

  try {
    // Pulisci tabella debug prima della nuova scansione
    clearDebugAnalysisTable();

    for (let time = 0; time < duration; time += stepSize) {
      const progress = (time / duration) * 100;
      updateStatus(`ü§ñ Analisi automatica: ${progress.toFixed(1)}%`);

      drawVideoFrame(video, time);
      await new Promise(resolve => setTimeout(resolve, 300));

      // Converti currentImage in base64 per l'API
      if (!currentImage) {
        console.warn('‚ö†Ô∏è currentImage non disponibile, salto frame');
        continue;
      }

      try {
        const imageBase64 = convertCurrentImageToBase64();
        const analysisResult = await analyzeImageViaAPI(imageBase64);

        if (analysisResult) {
          const score = analysisResult.frontality_score;
          const poseAngles = analysisResult.pose_angles;

          const frameData = {
            frameIndex: Math.floor(time / stepSize),
            time: time,
            score: score,
            pose: poseAngles,
            landmarks: analysisResult.landmarks,
            status: getFrontalityStatus(score)
          };

          results.push(frameData);

          // Aggiorna tabella debug in tempo reale
          addDebugAnalysisRow(frameData);
        }
      } catch (error) {
        console.warn(`‚ö†Ô∏è Errore analisi frame a ${time.toFixed(1)}s:`, error);
      }
    }

    // Ordina risultati per score
    results.sort((a, b) => b.score - a.score);

    // Salva risultati globalmente per riferimenti futuri
    window.videoAnalysisResults = results;

    // üéØ Evidenzia i migliori frame nella tabella (Top 10 invece di 5)
    const topResults = results.slice(0, 10);
    highlightBestFramesInTable(topResults);

    // üìä Statistiche dettagliate dei frame frontali
    const frontalFrames = results.filter(f => f.score > 0.7); // Score > 0.7 considerato frontale
    const veryFrontalFrames = results.filter(f => f.score > 0.8); // Score > 0.8 molto frontale
    const excellentFrames = results.filter(f => f.score > 0.9); // Score > 0.9 eccellente

    console.log('üìä STATISTICHE COMPLETE ANALISI VIDEO:');
    console.log(`- Frame totali analizzati: ${results.length}`);
    console.log(`- Frame frontali (>0.7): ${frontalFrames.length} (${((frontalFrames.length / results.length) * 100).toFixed(1)}%)`);
    console.log(`- Frame molto frontali (>0.8): ${veryFrontalFrames.length} (${((veryFrontalFrames.length / results.length) * 100).toFixed(1)}%)`);
    console.log(`- Frame eccellenti (>0.9): ${excellentFrames.length} (${((excellentFrames.length / results.length) * 100).toFixed(1)}%)`);

    // Mostra top 10 risultati
    console.log('üèÜ TOP 10 FRAME PI√ô FRONTALI:');
    topResults.forEach((result, index) => {
      const medal = index === 0 ? 'ü•á' : index === 1 ? 'ü•à' : index === 2 ? 'ü•â' : `#${index + 1}`;
      console.log(`${medal} t=${result.time.toFixed(1)}s - Score: ${result.score.toFixed(3)} - P:${result.pose.pitch.toFixed(1)}¬∞ Y:${result.pose.yaw.toFixed(1)}¬∞ R:${result.pose.roll.toFixed(1)}¬∞`);
    });

    // Vai al miglior frame
    if (topResults.length > 0) {
      const bestResult = topResults[0];
      const timeline = document.getElementById('video-timeline');
      if (timeline) {
        timeline.value = bestResult.time;
      }
      drawVideoFrame(video, bestResult.time);
      await analyzeCurrentVideoFrame();

      // ‚úÖ AGGIORNA IL CANVAS ALLA FINE DELLA SCANSIONE COMPLETA
      updateCanvasDisplay();

      // üîß ASSICURA che le sezioni sidebar rimangano visibili dopo l'analisi completa
      ensureSidebarSectionsVisible();

      updateStatus(`‚úÖ Scansione completa - Miglior frame: ${bestResult.time.toFixed(1)}s (Score: ${bestResult.score.toFixed(3)}) - ${frontalFrames.length}/${results.length} frame frontali (${veryFrontalFrames.length} molto frontali)`);
      showToast(`üìä Analisi completata! ${results.length} frame analizzati - ${frontalFrames.length} frontali (${veryFrontalFrames.length} molto frontali, ${excellentFrames.length} eccellenti)`, 'success');
    } else {
      updateStatus('‚ùå Nessun volto rilevato nel video');
      showToast('Nessun volto rilevato', 'warning');
    }

  } catch (error) {
    console.error('‚ùå Errore scansione automatica:', error);
    updateStatus('Errore durante la scansione automatica');
    showToast('Errore nella scansione', 'error');
  }
}