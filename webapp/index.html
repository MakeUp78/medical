<!DOCTYPE html>
<html lang="it">

<head>
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <meta charset="UTF-8">
    <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>üè• Facial Analysis Application v2.0 - Web Edition</title>
    <link rel="icon" type="image/x-icon" href="favicon.ico">
    <link rel="stylesheet" href="static/css/main.css?v=20260226-toolstrip">
    <link rel="stylesheet" href="static/css/components.css?v=20260129b">
    <link rel="stylesheet" href="static/css/tables.css?v=20260129b">
    <link rel="stylesheet" href="static/css/mobile-responsive.css?v=20260226b">
</head>

<body>
    <!-- Container principale identico alla app desktop -->
    <div class="main-container">
        <!-- SIDEBAR SINISTRA - Controlli identici all'app desktop -->
        <div class="left-sidebar" id="left-sidebar">
            <!-- Header Mobile Panel -->
            <div class="mobile-panel-header">
                <h2>Controlli</h2>
                <button class="mobile-panel-close" onclick="closeMobilePanel('left')">&times;</button>
            </div>
            <div class="scrollable-controls">

                <!-- Sezione UTENTE -->
                <div class="user-section">
                    <div class="user-info">
                        <div class="user-avatar">
                            <img id="user-avatar-img"
                                src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Ccircle cx='50' cy='50' r='50' fill='%23e0e0e0'/%3E%3Ctext x='50%25' y='50%25' dominant-baseline='middle' text-anchor='middle' font-size='40' fill='%23666'%3Eüë§%3C/text%3E%3C/svg%3E"
                                alt="Avatar" style="width: 100%; height: 100%; border-radius: 50%; object-fit: cover;">
                        </div>
                        <div class="user-details">
                            <div class="user-name" id="user-name">Caricamento...</div>
                            <div class="user-role" id="user-role">
                                <span class="role-badge operator" id="role-badge">Operatore</span>
                            </div>
                        </div>
                    </div>
                    <div style="display: flex; gap: 0.5rem; margin-top: 0.5rem;">
                        <button class="btn-profile" onclick="window.location.href='profile.html'"
                            style="flex: 1; padding: 0.5rem; background: #2196F3; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 0.9rem;">
                            üë§ Profilo
                        </button>
                        <button id="admin-btn" class="btn-admin" onclick="window.location.href='admin.html'"
                            style="flex: 1; padding: 0.5rem; background: linear-gradient(135deg, #667eea, #764ba2); color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 0.9rem; display: none;">
                            Admin
                        </button>
                        <button class="btn-logout" onclick="logout()" style="flex: 1; padding: 0.5rem;">Esci</button>
                    </div>
                </div>

                <!-- Sezione SORGENTE -->
                <div class="section" data-expanded="false">
                    <div class="section-header" onclick="toggleSection(this)">
                        <button class="toggle-btn">üéØ SORGENTE</button>
                        <span class="icon">‚ñ∫</span>
                    </div>
                    <div class="section-content" style="display: none;">
                        <!-- Griglia pulsanti 2x2 identica -->
                        <div class="button-grid">
                            <button class="btn btn-primary" onclick="loadImage()">üìÅ Carica Immagine</button>
                            <button class="btn btn-info" onclick="loadVideo()">üé• Carica Video</button>
                            <button class="btn btn-success" onclick="startWebcam()">üìπ Avvia Webcam</button>
                            <button class="btn btn-warning" onclick="stopWebcam()">‚èπÔ∏è Stop Webcam</button>
                        </div>
                    </div>
                </div>

                <!-- Sezione IMPOSTAZIONI -->
                <div class="section" data-expanded="false" id="settings-section">
                    <div class="section-header" onclick="toggleSection(this)">
                        <button class="toggle-btn">‚öôÔ∏è IMPOSTAZIONI</button>
                        <span class="icon">‚ñ∫</span>
                    </div>
                    <div class="section-content" style="display: none;">
                        <div
                            style="background: #ffffff; border-radius: 10px; padding: 1rem; border: 1px solid #e2e8f0;">

                            <!-- Titolo -->
                            <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.75rem;">
                                <span style="font-size: 1.3em;">üì±</span>
                                <div>
                                    <div style="font-weight: 700; color: #1a202c; font-size: 0.95em;">Camera iPhone via
                                        Browser</div>
                                    <div style="font-size: 0.8em; color: #718096;">Nessuna app da installare</div>
                                </div>
                            </div>

                            <!-- QR Code -->
                            <div id="iphone-qr-container"
                                style="text-align: center; padding: 1rem; background: #f7fafc; border-radius: 8px; margin-bottom: 0.75rem; border: 1px solid #e2e8f0;">
                                <div id="qr-code-wrapper"
                                    style="background: white; display: inline-block; padding: 10px; border-radius: 6px; box-shadow: 0 1px 4px rgba(0,0,0,0.08);">
                                    <img id="qr-code-img" src="/api/qrcode.png" alt="QR Code"
                                        style="width: 160px; height: 160px; display: block;">
                                </div>
                                <p style="margin: 0.6rem 0 0.4rem; font-size: 0.82em; color: #4a5568;">Scansiona con la
                                    fotocamera iPhone</p>
                                <button onclick="refreshQRCode()" class="btn btn-secondary"
                                    style="font-size: 0.8em; padding: 0.3rem 0.8rem;">‚Üª Aggiorna QR</button>
                            </div>

                            <!-- Stato connessione -->
                            <div id="iphone-status-container"
                                style="display: flex; align-items: center; gap: 0.5rem; padding: 0.6rem 0.8rem; background: #fffbeb; border-radius: 6px; border-left: 3px solid #f6ad55; margin-bottom: 0.75rem;">
                                <span id="iphone-status-icon" style="font-size: 1.1em;">‚è≥</span>
                                <div>
                                    <div id="iphone-status-text"
                                        style="font-size: 0.83em; font-weight: 600; color: #744210;">Nessun iPhone
                                        connesso</div>
                                    <div id="iphone-device-info"
                                        style="display: none; font-size: 0.78em; color: #975a16;">ID: <span
                                            id="iphone-device-id">--</span></div>
                                </div>
                            </div>

                            <!-- Passi rapidi -->
                            <div
                                style="background: #f0fff4; border-radius: 6px; padding: 0.7rem 0.8rem; margin-bottom: 0.75rem; border: 1px solid #c6f6d5;">
                                <div
                                    style="font-size: 0.82em; font-weight: 700; color: #276749; margin-bottom: 0.4rem;">
                                    Come funziona</div>
                                <ol
                                    style="margin: 0 0 0 1.1rem; padding: 0; font-size: 0.81em; color: #2f855a; line-height: 1.7;">
                                    <li>Scansiona il QR con iPhone</li>
                                    <li>Apri il link dalla notifica</li>
                                    <li>Consenti accesso fotocamera</li>
                                    <li>Lo streaming parte in automatico</li>
                                </ol>
                            </div>

                            <!-- Nota WiFi -->
                            <div
                                style="display: flex; align-items: center; gap: 0.4rem; padding: 0.5rem 0.75rem; background: #ebf8ff; border-radius: 6px; border-left: 3px solid #63b3ed;">
                                <span style="font-size: 1em;">üì∂</span>
                                <span style="font-size: 0.8em; color: #2c5282;"><strong>Requisito:</strong> iPhone e PC
                                    sulla stessa rete WiFi</span>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Sezione ANALISI (unione di Rilevamenti + Misurazioni Predefinite) -->
                <div class="section" data-expanded="false">
                    <div class="section-header" onclick="toggleSection(this)">
                        <button class="toggle-btn">üî¨ ANALISI</button>
                        <span class="icon">‚ñ∫</span>
                    </div>
                    <div class="section-content" style="display: none;">
                        <!-- Griglia unificata 2 colonne - tutti pulsanti arancioni stessa dimensione -->
                        <div class="analysis-buttons">
                            <!-- Pulsanti Rilevamenti -->
                            <button class="btn btn-analysis" id="axis-btn" onclick="toggleAxis()">üìè Asse</button>
                            <button class="btn btn-analysis" id="landmarks-btn" onclick="toggleLandmarks()">üéØ
                                Landmarks</button>
                            <button class="btn btn-analysis" id="measure-btn" onclick="toggleMeasureMode()">üìê
                                Misura</button>

                            <!-- Pulsanti Misurazioni Predefinite -->
                            <button class="btn btn-analysis" onclick="measureFaceWidth(event)">üìê Larghezza
                                Viso</button>
                            <button class="btn btn-analysis" onclick="measureFaceHeight(event)">üìè Altezza Viso</button>
                            <button class="btn btn-analysis" onclick="measureEyeDistance(event)">üëÅÔ∏è Distanza
                                Occhi</button>
                            <button class="btn btn-analysis" onclick="measureNoseWidth(event)">üëÉ Larghezza
                                Naso</button>
                            <button class="btn btn-analysis" onclick="measureNoseHeight(event)">üìè Altezza Naso</button>
                            <button class="btn btn-analysis" onclick="measureMouthWidth(event)">üëÑ Larghezza
                                Bocca</button>
                            <button class="btn btn-analysis" onclick="measureEyebrowAreas(event)">‚úÇÔ∏è Aree
                                Sopracciglia</button>
                            <button class="btn btn-analysis" onclick="measureEyeAreas(event)">üëÅÔ∏è Aree Occhi</button>
                            <button class="btn btn-analysis" onclick="measureCheekWidth(event)"
                                style="display: none;">üòä Larghezza
                                Guance</button>
                            <button class="btn btn-analysis" onclick="measureForeheadWidth(event)">ü§î Larghezza
                                Fronte</button>
                            <button class="btn btn-analysis" onclick="measureChinWidth(event)" style="display: none;">üòÆ
                                Larghezza
                                Mento</button>
                            <button class="btn btn-analysis" onclick="measureFaceProfile(event)"
                                style="display: none;">üë§ Profilo
                                Viso</button>
                            <button class="btn btn-analysis" onclick="measureNoseAngle(event)" style="display: none;">üëÉ
                                Angolo Naso</button>
                            <button class="btn btn-analysis" onclick="measureMouthAngle(event)"
                                style="display: none;">üëÑ Angolo Bocca</button>
                            <button class="btn btn-analysis" onclick="measureFaceProportions(event)">üìè
                                Proporzioni</button>
                            <button class="btn btn-analysis" onclick="measureKeyDistances(event)"
                                style="display: none;">üîç Distanze
                                Chiave</button>
                            <button class="btn btn-analysis" onclick="measureFacialSymmetry(event)">‚öñÔ∏è
                                Simmetria</button>
                            <button class="btn btn-analysis" onclick="estimateAge(event)">üéÇ Stima Et√†</button>

                            <!-- Pulsante Analisi Completa - occupa tutta la larghezza -->
                            <button class="btn btn-analysis btn-analysis-complete"
                                onclick="performCompleteAnalysis(event)">
                                üß¨ ANALISI VISAGISTICA COMPLETA
                            </button>
                        </div>
                    </div>
                </div>

                <!-- Sezione SISTEMA SCORING (NASCOSTA) -->
                <div class="section" data-expanded="false" style="display: none;">
                    <div class="section-header" onclick="toggleSection(this)">
                        <button class="toggle-btn">‚öñÔ∏è SISTEMA SCORING</button>
                        <span class="icon">‚ñ∫</span>
                    </div>
                    <div class="section-content" style="display: none;">
                        <!-- Badge info score corrente -->
                        <div class="scoring-info" id="scoring-info">
                            Score corrente: 0.000
                        </div>

                        <!-- Sliders per i pesi -->
                        <div class="sliders-container">
                            <div class="slider-row">
                                <label>üëÉ Naso:</label>
                                <input type="range" id="nose-slider" class="slider" min="0" max="1" step="0.01"
                                    value="0.30" oninput="updateWeight('nose', this.value)">
                                <span class="value" id="nose-value">0.30</span>
                            </div>

                            <div class="slider-row">
                                <label>üíã Bocca:</label>
                                <input type="range" id="mouth-slider" class="slider" min="0" max="1" step="0.01"
                                    value="0.25" oninput="updateWeight('mouth', this.value)">
                                <span class="value" id="mouth-value">0.25</span>
                            </div>

                            <div class="slider-row">
                                <label>‚öñÔ∏è Simm.:</label>
                                <input type="range" id="symmetry-slider" class="slider" min="0" max="1" step="0.01"
                                    value="0.25" oninput="updateWeight('symmetry', this.value)">
                                <span class="value" id="symmetry-value">0.25</span>
                            </div>

                            <div class="slider-row">
                                <label>üëÅÔ∏è Occhi:</label>
                                <input type="range" id="eye-slider" class="slider" min="0" max="1" step="0.01"
                                    value="0.20" oninput="updateWeight('eye', this.value)">
                                <span class="value" id="eye-value">0.20</span>
                            </div>
                        </div>

                        <!-- Pulsanti preset -->
                        <div class="preset-buttons">
                            <button class="btn btn-preset" onclick="resetWeights()">üîÑ Reset</button>
                            <button class="btn btn-preset" onclick="presetNoseFocus()">üëÉ Focus Naso</button>
                            <button class="btn btn-preset" onclick="presetLessSymmetry()">‚öñÔ∏è Meno Simmetria</button>
                        </div>
                    </div>
                </div>

                <!-- Sezione CORREZIONE PROGETTAZIONE -->
                <div class="section" data-expanded="false">
                    <div class="section-header" onclick="toggleSection(this)">
                        <button class="toggle-btn">‚úÇÔ∏è CORREZIONE PROGETTAZIONE</button>
                        <span class="icon">‚ñ∫</span>
                    </div>
                    <div class="section-content" style="display: none;">
                        <div class="eyebrow-info">
                            Quale sopracciglio piace di pi√π alla cliente? Quello alla tua DESTRA o alla tua SINISTRA?
                        </div>

                        <div class="eyebrow-buttons">
                            <button class="btn btn-analysis" id="green-dots-btn" onclick="toggleGreenDots()">ÔøΩ Trova
                                Differenze</button>
                            <button class="btn btn-eyebrow" onclick="show_left_eyebrow_with_voice()">‚úÇÔ∏è Preferenza
                                Destra</button>
                            <button class="btn btn-eyebrow" onclick="show_right_eyebrow_with_voice()">‚úÇÔ∏è Preferenza
                                Sinistra</button>
                        </div>

                        <!-- Pannello Parametri Rilevamento White Dots -->
                        <div id="white-dots-params-panel"
                            style="display: none; margin-top: 15px; padding: 12px; background: #1a1a2e; border-radius: 8px; border: 1px solid #4a4a6a;">
                            <div
                                style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                                <span style="font-weight: bold; color: #00d4ff;">‚öôÔ∏è Parametri Rilevamento</span>
                                <button onclick="resetWhiteDotsParams()"
                                    style="padding: 4px 8px; font-size: 11px; background: #ff6b6b; border: none; border-radius: 4px; color: white; cursor: pointer;">Reset</button>
                            </div>

                            <!-- Badge info 2-pass automatico -->
                            <div
                                style="padding:10px 12px; background:#0d2818; border:1px solid #2ea043; border-radius:6px; margin-bottom:14px;">
                                <div style="color:#3fb950; font-weight:bold; font-size:12px; margin-bottom:6px;">üéØ
                                    Rilevamento automatico 2-pass</div>
                                <div style="color:#8b949e; font-size:11px; line-height:1.6;">
                                    <span style="color:#58a6ff;">Pass 1</span> (selettivit√† <span
                                        id="badge-p1-perc">50</span>%, sat-cap <span id="badge-p1-sat">30</span>%) ‚Üí <b
                                        style="color:#fff;">LB</b> + <b style="color:#fff;">RB</b> ‚Äî punti pi√π esterni
                                    (code)<br>
                                    <span style="color:#f78166;">Pass 2</span> (selettivit√† <span
                                        id="badge-p2-perc">80</span>%, sat-cap <span id="badge-p2-sat">25</span>%) ‚Üí <b
                                        style="color:#fff;">4 punti sx</b> + <b style="color:#fff;">4 punti dx</b> ‚Äî
                                    punti centrali<br>
                                    <span style="color:#3fb950;">Totale atteso: 10 punti</span>
                                </div>
                            </div>

                            <!-- Slider avanzati pass1/pass2 ‚Äî visibili SOLO per immagini statiche -->
                            <div id="adaptive-advanced-params"
                                style="display:none; margin-bottom:14px; padding:10px; background:#0d1117; border:1px solid #30363d; border-radius:6px;">
                                <div style="color:#58a6ff; font-size:11px; font-weight:bold; margin-bottom:10px;">üîß
                                    Regolazione fine (solo immagini statiche)</div>

                                <div
                                    style="color:#8b949e; font-size:10px; margin-bottom:6px; text-transform:uppercase; letter-spacing:.5px;">
                                    Pass 1 ‚Äî code (LB / RB)</div>
                                <div class="param-slider-group">
                                    <label>Selettivit√†: <span id="p1-percentile-value">60</span>%</label>
                                    <input type="range" id="p1-percentile-slider" min="20" max="85" value="60"
                                        oninput="updateAdaptiveParam('pass1_percentile', this.value, 'p1-percentile-value', 'badge-p1-perc')">
                                    <small>‚¨Ö include pi√π candidati ‚Äî pi√π restrittivo ‚û°</small>
                                </div>
                                <div class="param-slider-group">
                                    <label>Filtro colore: <span id="p1-sat-cap-value">25</span>%</label>
                                    <input type="range" id="p1-sat-cap-slider" min="10" max="70" value="25"
                                        oninput="updateAdaptiveParam('pass1_sat_cap', this.value, 'p1-sat-cap-value', 'badge-p1-sat')">
                                    <small>Abbassa se la pelle genera falsi positivi nelle code</small>
                                </div>

                                <div
                                    style="color:#f78166; font-size:10px; margin:10px 0 6px; text-transform:uppercase; letter-spacing:.5px;">
                                    Pass 2 ‚Äî punti centrali (4+4)</div>
                                <div class="param-slider-group">
                                    <label>Selettivit√†: <span id="p2-percentile-value">80</span>%</label>
                                    <input type="range" id="p2-percentile-slider" min="50" max="97" value="80"
                                        oninput="updateAdaptiveParam('pass2_percentile', this.value, 'p2-percentile-value', 'badge-p2-perc')">
                                    <small>‚¨Ö pi√π punti trovati ‚Äî solo i pi√π brillanti ‚û°</small>
                                </div>
                                <div class="param-slider-group">
                                    <label>Filtro colore: <span id="p2-sat-cap-value">20</span>%</label>
                                    <input type="range" id="p2-sat-cap-slider" min="10" max="70" value="20"
                                        oninput="updateAdaptiveParam('pass2_sat_cap', this.value, 'p2-sat-cap-value', 'badge-p2-sat')">
                                    <small>Abbassa se compaiono macchie colorate sui punti centrali</small>
                                </div>
                            </div>

                            <!-- Cluster Size Min -->
                            <div class="param-slider-group">
                                <label>Dimensione Min Cluster: <span id="cluster-min-value">6</span>px</label>
                                <input type="range" id="cluster-min-slider" min="1" max="50" value="6"
                                    oninput="updateWhiteDotsParam('cluster_size_min', this.value)">
                                <small>Pi√π alto = ignora puntini piccoli (rumore)</small>
                            </div>

                            <!-- Cluster Size Max -->
                            <div class="param-slider-group">
                                <label>Dimensione Max Cluster: <span id="cluster-max-value">300</span>px</label>
                                <input type="range" id="cluster-max-slider" min="20" max="400" value="300"
                                    oninput="updateWhiteDotsParam('cluster_size_max', this.value)">
                                <small>Pi√π alto = include cluster pi√π grandi (fino a 400px)</small>
                            </div>

                            <!-- Min Distance -->
                            <div class="param-slider-group">
                                <label>Distanza Min tra Punti: <span id="min-distance-value">10</span>px</label>
                                <input type="range" id="min-distance-slider" min="5" max="50" value="10"
                                    oninput="updateWhiteDotsParam('min_distance', this.value)">
                                <small>Pi√π alto = punti pi√π distanziati</small>
                            </div>

                            <!-- Pulsanti azione -->
                            <div style="display: flex; gap: 8px; margin-top: 12px;">
                                <!-- Pulsante Contagocce -->
                                <button id="eyedropper-btn" onclick="toggleEyedropper()"
                                    style="flex: 1; padding: 10px; background: linear-gradient(135deg, #9b59b6, #8e44ad); border: none; border-radius: 6px; color: white; font-weight: bold; cursor: pointer;">
                                    üíß Contagocce
                                </button>
                                <!-- Pulsante Rileva -->
                                <button id="detect-with-params-btn" onclick="detectWithCurrentParams()"
                                    style="flex: 2; padding: 10px; background: linear-gradient(135deg, #00d4ff, #0099cc); border: none; border-radius: 6px; color: white; font-weight: bold; cursor: pointer;">
                                    üîç Rileva
                                </button>
                            </div>

                            <!-- Pannello risultati contagocce -->
                            <div id="eyedropper-results"
                                style="display: none; margin-top: 10px; padding: 10px; background: #0d0d1a; border-radius: 6px; border: 1px solid #9b59b6;">
                                <div style="font-weight: bold; color: #9b59b6; margin-bottom: 8px;">üíß Analisi Punto
                                    Selezionato</div>
                                <div id="eyedropper-color-preview"
                                    style="width: 100%; height: 30px; border-radius: 4px; margin-bottom: 8px; border: 1px solid #444;">
                                </div>
                                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 4px; font-size: 11px;">
                                    <div>RGB: <span id="eyedropper-rgb" style="color: #00d4ff;">-</span></div>
                                    <div>Pos: <span id="eyedropper-pos" style="color: #00d4ff;">-</span></div>
                                    <div>Hue: <span id="eyedropper-hue" style="color: #00d4ff;">-</span>¬∞</div>
                                    <div>Sat: <span id="eyedropper-sat" style="color: #00d4ff;">-</span>%</div>
                                    <div>Val: <span id="eyedropper-val" style="color: #00d4ff;">-</span>%</div>
                                    <div>Cluster: <span id="eyedropper-cluster" style="color: #00d4ff;">-</span>px</div>
                                </div>
                                <div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid #333;">
                                    <div style="font-size: 10px; color: #888;">Suggerimento parametri:</div>
                                    <div id="eyedropper-suggestion"
                                        style="font-size: 11px; color: #00ff88; margin-top: 4px;">
                                        Clicca su un puntino bianco nell'immagine
                                    </div>
                                </div>
                                <button onclick="applyEyedropperSuggestion()" id="apply-suggestion-btn"
                                    style="display: none; width: 100%; margin-top: 8px; padding: 6px; background: #27ae60; border: none; border-radius: 4px; color: white; font-size: 11px; cursor: pointer;">
                                    ‚úì Applica suggerimento agli sliders
                                </button>
                            </div>

                            <!-- Info parametri correnti -->
                            <div id="current-params-info"
                                style="margin-top: 10px; padding: 8px; background: #0d0d1a; border-radius: 4px; font-size: 11px; color: #888;">
                                Modifica i parametri e clicca "Rileva" per testare
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Sezione ASSISTENTE VOCALE -->
                <div class="section" data-expanded="false" id="voice-assistant-section">
                    <div class="section-header" onclick="toggleSection(this)">
                        <button class="toggle-btn">üé§ ASSISTENTE VOCALE</button>
                        <span class="icon">‚ñ∫</span>
                    </div>
                    <div class="section-content" style="display: none;">
                        <!-- Voice Assistant Content -->
                        <div id="voice-assistant-sidebar-content">
                            <!-- Status -->
                            <div class="voice-status-sidebar" id="voice-status-sidebar">
                                <div class="status-indicator-sidebar active" id="status-indicator-sidebar">üü¢</div>
                                <span id="status-text-sidebar">Pronto</span>
                            </div>

                            <!-- Controlli principali -->
                            <div class="voice-controls-sidebar">
                                <button class="btn btn-primary" id="toggle-listening-btn-sidebar"
                                    onclick="toggleVoiceListening()">
                                    <span id="listening-icon-sidebar">üé§</span>
                                    <span id="listening-text-sidebar">Avvia Ascolto</span>
                                </button>

                                <button class="btn btn-secondary" id="toggle-mute-btn-sidebar"
                                    onclick="toggleVoiceMute()">
                                    <span id="mute-icon-sidebar">üîä</span>
                                    <span id="mute-text-sidebar">Muto</span>
                                </button>
                            </div>

                            <!-- Info riconoscimento -->
                            <div class="voice-info-sidebar" id="voice-last-command-sidebar">
                                Ultimo comando: <span id="last-command-text-sidebar">Nessuno</span>
                            </div>

                            <!-- Messaggi rapidi -->
                            <div class="voice-quick-messages-sidebar" style="display:none;">
                                <div class="quick-msg-title-sidebar">Messaggi Rapidi:</div>
                                <div class="quick-msg-buttons-sidebar">
                                    <button class="btn btn-info btn-small"
                                        onclick="voiceAssistant.speakMessage('welcome')">üëã Benvenuto</button>
                                    <button class="btn btn-info btn-small"
                                        onclick="voiceAssistant.speakMessage('axis_on')">üìè Asse On</button>
                                    <button class="btn btn-info btn-small"
                                        onclick="voiceAssistant.speakMessage('landmarks_on')">üéØ Landmarks On</button>
                                </div>
                            </div>

                            <!-- Lista comandi vocali disponibili -->
                            <details class="voice-commands-help-sidebar">
                                <summary>üìã Comandi Vocali</summary>
                                <div class="commands-list-sidebar">
                                    <div class="command-item-sidebar">
                                        <strong>"Kimerika"</strong> ‚Üí Attiva ascolto comandi
                                    </div>
                                    <div class="command-item-sidebar">
                                        <strong>"Asse"</strong> ‚Üí Attiva/disattiva asse di simmetria
                                    </div>
                                    <div class="command-item-sidebar">
                                        <strong>"Landmarks"</strong> ‚Üí Attiva/disattiva punti facciali
                                    </div>
                                    <div class="command-item-sidebar">
                                        <strong>"Punti verdi"</strong> ‚Üí Rileva punti verdi sopracciglia
                                    </div>
                                    <div class="command-item-sidebar">
                                        <strong>"Avvia webcam"</strong> ‚Üí Avvia webcam
                                    </div>
                                    <div class="command-item-sidebar">
                                        <strong>"Stop webcam"</strong> ‚Üí Ferma webcam
                                    </div>
                                    <div class="command-item-sidebar">
                                        <strong>"Carica immagine"</strong> ‚Üí Apri caricamento immagine
                                    </div>
                                    <div class="command-item-sidebar">
                                        <strong>"Carica video"</strong> ‚Üí Apri caricamento video
                                    </div>
                                    <div class="command-item-sidebar">
                                        <strong>"Analizza"</strong> ‚Üí Avvia analisi facciale
                                    </div>
                                    <div class="command-item-sidebar">
                                        <strong>"Pulisci"</strong> ‚Üí Pulisci canvas
                                    </div>
                                    <div class="command-item-sidebar">
                                        <strong>"Simmetria"</strong> ‚Üí Analisi simmetria viso
                                    </div>
                                    <div class="command-item-sidebar">
                                        <strong>"Sopracciglio sinistro"</strong> ‚Üí Analizza sopracciglio sx
                                    </div>
                                    <div class="command-item-sidebar">
                                        <strong>"Sopracciglio destro"</strong> ‚Üí Analizza sopracciglio dx
                                    </div>
                                </div>
                            </details>
                        </div>
                    </div>
                </div>


            </div>
        </div>

        <!-- CANVAS CENTRALE identico al matplotlib canvas -->
        <div class="canvas-container">
            <!-- Toolbar strumenti -->
            <div class="canvas-toolbar">
                <button class="tool-btn" data-tool="pan" onclick="setTool('pan')" title="Sposta vista canvas">‚úã
                    Pan</button>
                <button class="tool-btn" data-tool="zoom-in" onclick="setTool('zoom-in')"
                    title="Ingrandisci al click">üîç+ Zoom In</button>
                <button class="tool-btn" data-tool="zoom-out" onclick="setTool('zoom-out')"
                    title="Rimpicciolisci al click">üîç- Zoom Out</button>
                <button class="tool-btn" onclick="rotateImageClockwise()" title="Ruota immagine 1¬∞ in senso orario">‚Üª
                    Ruota ‚ü≤</button>
                <button class="tool-btn" onclick="rotateImageCounterClockwise()"
                    title="Ruota immagine 1¬∞ in senso antiorario">‚Ü∫ Ruota ‚ü≥</button>
                <button class="tool-btn" data-tool="line" onclick="setTool('line')" title="Disegna linea">üìè
                    Linea</button>
                <button class="tool-btn" data-tool="couple" onclick="setTool('couple')"
                    title="Disegna coppia di linee verticali speculari">‚öñÔ∏è
                    Coppia</button>
                <button class="tool-btn" onclick="clearAllMeasurementOverlays()" title="Pulisci tutte le misurazioni">üìê
                    Pulisci Mis.</button>
                <button class="tool-btn" onclick="clearCanvas()" title="Pulisci canvas completamente"
                    style="display: none;">üßπ
                    Pulisci</button>
            </div>

            <!-- Canvas principale -->
            <div class="canvas-wrapper">
                <canvas id="main-canvas"></canvas>
            </div>

            <!-- Video webcam nascosto -->
            <video id="webcam-video" autoplay muted style="position: absolute; left: -9999px; top: -9999px;"></video>

            <!-- Info cursore -->
            <div class="cursor-info" id="cursor-info">
                Mouse: (0, 0) | Zoom: 100%
            </div>
        </div>

        <!-- SIDEBAR DESTRA identica alla colonna destra dell'app -->
        <div class="right-sidebar" id="right-sidebar">
            <!-- Header Mobile Panel -->
            <div class="mobile-panel-header">
                <h2>Dati & Anteprima</h2>
                <button class="mobile-panel-close" onclick="closeMobilePanel('right')">&times;</button>
            </div>

            <!-- Anteprima - PRIMA POSIZIONE -->
            <div class="section" data-expanded="false">
                <div class="section-header" onclick="toggleSection(this)">
                    <button class="toggle-btn">üìπ ANTEPRIMA</button>
                    <span class="icon">‚ñ∫</span>
                </div>
                <div class="section-content webcam-preview-content" style="display: none;">
                    <canvas id="webcam-preview-canvas"></canvas>
                    <div id="webcam-preview-info">Anteprima non attiva</div>

                    <!-- Monitor debug websocket -->
                    <div class="status-info-frame">
                        <div class="best-frame-info" id="best-frame-info">
                            Nessun frame analizzato
                        </div>
                        <div class="best-frame-info" id="live-processing-stats"
                            style="font-size:0.8em;opacity:0.7;margin-top:4px;">
                        </div>
                    </div>
                </div>
            </div>

            <!-- Sezione Dati Analisi Unificata -->
            <div class="section" data-expanded="false">
                <div class="section-header" onclick="toggleSection(this)">
                    <button class="toggle-btn">üìä DATI ANALISI</button>
                    <span class="icon">‚ñ∫</span>
                </div>
                <div class="section-content" style="display: none;">
                    <!-- Tabs per selezionare il tipo di dati -->
                    <div class="unified-tabs">
                        <button class="unified-tab active" data-tab="measurements"
                            onclick="switchUnifiedTab('measurements', event)">
                            üìè Misurazioni
                        </button>
                        <button class="unified-tab" data-tab="landmarks" onclick="switchUnifiedTab('landmarks', event)">
                            üéØ Landmarks
                        </button>
                        <button class="unified-tab" data-tab="debug" onclick="switchUnifiedTab('debug', event)">
                            üêõ Debug
                        </button>
                    </div>

                    <!-- Tabella Unificata -->
                    <div class="table-container">
                        <table class="data-table" id="unified-table">
                            <thead id="unified-table-head">
                                <!-- Header dinamico basato sul tab selezionato -->
                            </thead>
                            <tbody id="unified-table-body">
                                <!-- Dati dinamici verranno inseriti qui -->
                            </tbody>
                        </table>
                    </div>


                </div>
            </div>

            <!-- Sezioni originali (nascoste, ma mantengono i dati per compatibilit√†) -->
            <div style="display: none;">
                <!-- Sezione Misurazioni Originale (nascosta) -->
                <div class="section" data-expanded="false">
                    <div class="section-content">
                        <div class="table-container">
                            <table class="data-table" id="measurements-table">
                                <thead>
                                    <tr>
                                        <th>üìè Tipo Misurazione</th>
                                        <th>üìä Valore</th>
                                        <th>üìê Unit√†</th>
                                        <th>‚úÖ Stato</th>
                                    </tr>
                                </thead>
                                <tbody id="measurements-data">
                                    <!-- Dati dinamici verranno inseriti qui -->
                                </tbody>
                            </table>
                        </div>
                    </div>
                </div>

                <!-- Sezione Landmarks Originale (nascosta) -->
                <div class="section" data-expanded="false">
                    <div class="section-content">
                        <div class="table-container">
                            <table class="data-table" id="landmarks-table">
                                <thead>
                                    <tr>
                                        <th>üé®</th>
                                        <th>ID</th>
                                        <th>Nome</th>
                                        <th>X</th>
                                        <th>Y</th>
                                    </tr>
                                </thead>
                                <tbody id="landmarks-data">
                                    <!-- Dati landmarks verranno inseriti qui -->
                                </tbody>
                            </table>
                        </div>

                        <!-- Controlli paginazione landmarks -->
                        <div class="landmarks-controls" id="landmarks-pagination" style="display: none;">
                            <button class="btn btn-mini" onclick="showLandmarksPage('prev')" id="landmarks-prev">‚óÄ
                                Prec</button>
                            <span class="landmarks-page-info" id="landmarks-page-info">Pagina 1/1</span>
                            <button class="btn btn-mini" onclick="showLandmarksPage('next')" id="landmarks-next">Succ
                                ‚ñ∂</button>
                            <button class="btn btn-mini" onclick="showAllLandmarks()"
                                title="Mostra tutti i landmarks in una nuova finestra">üìã Tutti</button>
                        </div>
                    </div>
                </div>

                <!-- Debug Analysis Originale (nascosta) -->
                <div class="section" data-expanded="false">
                    <div class="section-content debug-content">
                        <div class="table-container">
                            <table class="data-table debug-table" id="debug-table">
                                <thead>
                                    <tr>
                                        <th>Frame</th>
                                        <th>Tempo</th>
                                        <th>Score</th>
                                        <th>Yaw</th>
                                        <th>Pitch</th>
                                        <th>Roll</th>
                                        <th>Stato</th>
                                    </tr>
                                </thead>
                                <tbody id="debug-data">
                                    <!-- Dati debug verranno inseriti qui -->
                                </tbody>
                            </table>
                        </div>
                        <div class="debug-controls">
                            <button class="btn btn-small" onclick="clearDebugLogs()">Pulisci</button>
                            <button class="btn btn-small" onclick="ensureSidebarSectionsVisible()"
                                title="Ripristina visibilit√† sezioni">üîß Ripristina UI</button>
                            <label class="auto-scroll-label">
                                <input type="checkbox" id="auto-scroll"> Auto
                            </label>
                        </div>
                    </div>
                </div>
            </div>
        </div>

    </div>
    </div>

    <!-- Finestra modale per anteprima video -->
    <div id="preview-modal" class="modal" style="display: none;">
        <div class="modal-content">
            <div class="modal-header">
                <h3 id="modal-title">Anteprima Video - Analisi in corso</h3>
                <span class="close" onclick="closeVideoPreview()">&times;</span>
            </div>
            <div class="modal-body">
                <!-- Player video per anteprima in tempo reale -->
                <div id="video-player-container" style="display: none;">
                    <video id="preview-video" width="640" height="480" controls>
                        Il tuo browser non supporta il tag video.
                    </video>
                    <div class="video-controls">
                        <button id="analyze-current-frame" class="btn btn-primary">üéØ Analizza Frame Corrente</button>
                        <button id="auto-analyze" class="btn btn-success">ü§ñ Analisi Automatica</button>
                        <button id="stop-analysis" class="btn btn-danger" style="display: none;">‚èπÔ∏è Ferma</button>
                    </div>
                </div>

                <!-- Canvas per risultati analisi -->
                <canvas id="preview-canvas" width="640" height="480" style="display: none;"></canvas>

                <!-- Area info/status -->
                <div class="preview-info" id="preview-info">
                    In attesa del video...
                </div>
            </div>
        </div>
    </div>

    <!-- Modal separato per l'analisi video automatica -->
    <div id="video-analysis-modal" class="modal" style="display: none;">
        <div class="modal-content">
            <div class="modal-header">
                <h3>Analisi Video Automatica</h3>
                <span class="close" onclick="closeVideoAnalysis()">&times;</span>
            </div>
            <div class="modal-body">
                <div id="video-analysis-status">
                    <div class="analysis-progress">
                        <div class="spinner"></div>
                        <p>Analisi in corso...</p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Modal Analisi Visagistica Completa -->
    <div id="analysis-modal" class="modal" style="display: none;">
        <div class="modal-content" style="max-width: 90%; max-height: 90vh; overflow-y: auto;">
            <div class="modal-header">
                <span style="opacity: 0.6; margin-right: 10px; font-size: 20px;">‚ãÆ‚ãÆ</span>
                <h3>üß¨ Analisi Visagistica Completa</h3>
                <span class="close" onclick="closeAnalysisModal()">&times;</span>
            </div>
            <div class="modal-body">
                <!-- Loading spinner -->
                <div id="analysis-loading" style="text-align: center; padding: 40px; display: none;">
                    <div class="spinner"
                        style="width: 60px; height: 60px; border: 5px solid #f3f3f3; border-top: 5px solid #667eea; border-radius: 50%; animation: spin 1s linear infinite; margin: 0 auto;">
                    </div>
                    <p style="margin-top: 20px; font-size: 16px; color: #667eea;">Analisi in corso...</p>
                </div>

                <!-- Report completo -->
                <div id="analysis-report" style="display: none;">
                    <div
                        style="margin-bottom: 20px; display: flex; gap: 10px; justify-content: center; flex-wrap: wrap;">
                        <button class="btn btn-success" onclick="generateAnalysisPDF()"
                            style="font-size: 16px; padding: 12px 24px;">
                            üìÑ Genera PDF
                        </button>
                        <button class="btn btn-info" id="read-report-btn" onclick="toggleReportReading()"
                            style="font-size: 16px; padding: 12px 24px;">
                            üîä Leggi Report
                        </button>
                        <button class="btn btn-secondary" onclick="closeAnalysisModal()"
                            style="font-size: 16px; padding: 12px 24px;">
                            ‚úñÔ∏è Chiudi
                        </button>
                    </div>

                    <div id="report-content"
                        style="background: #f9f9f9; padding: 20px; border-radius: 8px; font-family: 'Courier New', monospace; white-space: pre-wrap; line-height: 1.6; color: #333;">
                        <!-- Il report verr√† inserito qui -->
                    </div>

                    <!-- Immagini debug (opzionale) -->
                    <div id="debug-images-container" style="margin-top: 30px; display: none;">
                        <h4 style="margin-bottom: 15px;">üì∏ Immagini di Analisi</h4>
                        <div id="debug-images-grid"
                            style="display: grid; grid-template-columns: repeat(auto-fill, minmax(300px, 1fr)); gap: 20px;">
                            <!-- Le immagini verranno inserite qui -->
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Status bar (nascosta su mobile) -->
    <div class="status-bar">
        <div class="status-text" id="status-text">Pronto</div>
        <div class="progress-container" id="progress-container" style="display: none;">
            <div class="progress-bar" id="progress-bar"></div>
            <span class="progress-text" id="progress-text">0%</span>
        </div>
    </div>

    <!-- ========================================
         MOBILE UI ELEMENTS
         ======================================== -->

    <!-- Overlay per pannelli mobile -->
    <div class="mobile-overlay" id="mobile-overlay" onclick="closeAllMobilePanels()"></div>

    <!-- Bottom Navigation Mobile -->
    <nav class="mobile-bottom-nav" id="mobile-bottom-nav">
        <button class="mobile-nav-item" data-panel="home" onclick="openMobileHomePanel()">
            <span class="mobile-nav-icon">üè†</span>
            <span class="mobile-nav-label">Home</span>
        </button>
        <button class="mobile-nav-item" data-panel="differenze" onclick="toggleGreenDots(); focusCanvas();">
            <span class="mobile-nav-icon">üîç</span>
            <span class="mobile-nav-label">Differenze</span>
        </button>
        <button class="mobile-nav-item" data-panel="camera" onclick="startWebcam();">
            <span class="mobile-nav-icon">üì∑</span>
            <span class="mobile-nav-label">Camera</span>
        </button>
        <button class="mobile-nav-item" data-panel="dati" onclick="openMobileDatiPanel();">
            <span class="mobile-nav-icon">üìä</span>
            <span class="mobile-nav-label">Dati</span>
        </button>
        <button class="mobile-nav-item" data-panel="tools" onclick="openMobileToolsPanel()">
            <span class="mobile-nav-icon">üõ†Ô∏è</span>
            <span class="mobile-nav-label">Strumenti</span>
        </button>
    </nav>

    <!-- Quick Actions Panel per Camera (Mobile) -->
    <div class="mobile-quick-panel" id="mobile-camera-panel">
        <div class="mobile-quick-panel-content">
            <div class="mobile-quick-panel-header">
                <h3>üì∑ Sorgente</h3>
                <button class="mobile-panel-close" onclick="closeMobileQuickPanel('camera')">&times;</button>
            </div>
            <div class="mobile-quick-panel-buttons">
                <button class="btn btn-primary btn-mobile-action"
                    onclick="loadImage(); closeMobileQuickPanel('camera');">
                    üìÅ Carica Immagine
                </button>
                <button class="btn btn-info btn-mobile-action" onclick="loadVideo(); closeMobileQuickPanel('camera');">
                    üé• Carica Video
                </button>
                <button class="btn btn-success btn-mobile-action"
                    onclick="startWebcam(); closeMobileQuickPanel('camera');">
                    üìπ Avvia Webcam
                </button>
                <button class="btn btn-warning btn-mobile-action"
                    onclick="stopWebcam(); closeMobileQuickPanel('camera');">
                    ‚èπÔ∏è Stop Webcam
                </button>
            </div>
        </div>
    </div>

    <!-- Tools Strip Panel (Mobile) - barra orizzontale scrollabile -->
    <div class="mobile-quick-panel mobile-tools-strip-panel" id="mobile-tools-panel">
        <div class="mobile-tools-strip" id="mobile-tools-strip">
            <!-- Toggle tools -->
            <button class="btn-tool-strip" id="mobile-strip-axis-btn"
                onclick="toggleAxis(); updateMobileToolsState();">üìè Asse</button>
            <button class="btn-tool-strip" id="mobile-strip-landmarks-btn"
                onclick="toggleLandmarks(); updateMobileToolsState();">üéØ Landmarks</button>
            <button class="btn-tool-strip" id="mobile-strip-measure-btn"
                onclick="toggleMeasureMode(); updateMobileToolsState();">üìê Misura</button>
            <!-- Misurazioni -->
            <button class="btn-tool-strip" onclick="measureFaceWidth(event);">üìê L.Viso</button>
            <button class="btn-tool-strip" onclick="measureFaceHeight(event);">üìè H.Viso</button>
            <button class="btn-tool-strip" onclick="measureEyeDistance(event);">üëÅÔ∏è Occhi</button>
            <button class="btn-tool-strip" onclick="measureNoseWidth(event);">üëÉ L.Naso</button>
            <button class="btn-tool-strip" onclick="measureNoseHeight(event);">üìè H.Naso</button>
            <button class="btn-tool-strip" onclick="measureMouthWidth(event);">üëÑ L.Bocca</button>
            <button class="btn-tool-strip" onclick="measureEyebrowAreas(event);">‚úÇÔ∏è Sopracciglia</button>
            <button class="btn-tool-strip" onclick="measureEyeAreas(event);">üëÅÔ∏è Aree Occhi</button>
            <button class="btn-tool-strip" onclick="measureForeheadWidth(event);">ü§î L.Fronte</button>
            <button class="btn-tool-strip" onclick="measureFaceProportions(event);">üìè Proporzioni</button>
            <button class="btn-tool-strip" onclick="measureFacialSymmetry(event);">‚öñÔ∏è Simmetria</button>
            <button class="btn-tool-strip" onclick="estimateAge(event);">üéÇ Et√†</button>
            <button class="btn-tool-strip btn-tool-strip-complete" onclick="performCompleteAnalysis(event);">üß¨ Analisi
                Completa</button>
        </div>
    </div>

    <!-- Scripts -->

    <!-- ========================================
         MOBILE UI JAVASCRIPT
         ======================================== -->
    <script>
        (function () {
            'use strict';

            // ========================================
            // VARIABILI E STATO MOBILE
            // ========================================
            let currentOpenPanel = null;
            let currentOpenQuickPanel = null;
            const isMobile = () => window.innerWidth <= 768;

            // ========================================
            // FIX ALTEZZA VIEWPORT MOBILE (100vh bug)
            // ========================================
            function setVH() {
                const vh = window.innerHeight * 0.01;
                document.documentElement.style.setProperty('--vh', `${vh}px`);
                console.log(`üìê Viewport height aggiornato: ${window.innerHeight}px`);
            }

            setVH();
            window.addEventListener('resize', setVH);
            window.addEventListener('orientationchange', () => {
                setTimeout(setVH, 100);
            });

            // Previeni zoom accidentale su iOS
            document.addEventListener('gesturestart', function (e) {
                e.preventDefault();
            });

            // Previeni doppio tap zoom
            let lastTouchEnd = 0;
            document.addEventListener('touchend', function (e) {
                const now = Date.now();
                if (now - lastTouchEnd <= 300) {
                    e.preventDefault();
                }
                lastTouchEnd = now;
            }, false);

            // ========================================
            // GESTIONE PANNELLI MOBILE
            // ========================================
            window.openMobilePanel = function (side) {
                if (!isMobile()) return;

                closeAllMobilePanels();

                const panel = document.getElementById(`${side}-sidebar`);
                const overlay = document.getElementById('mobile-overlay');

                if (panel) {
                    panel.classList.add('mobile-panel-open');
                    overlay.classList.add('active');
                    currentOpenPanel = side;

                    // Aggiorna stato nav
                    updateNavState(side);

                    // Previeni scroll del body
                    document.body.style.overflow = 'hidden';
                }
            };

            window.closeMobilePanel = function (side) {
                const panel = document.getElementById(`${side}-sidebar`);
                const overlay = document.getElementById('mobile-overlay');

                if (panel) {
                    panel.classList.remove('mobile-panel-open');
                }

                if (overlay && !currentOpenQuickPanel) {
                    overlay.classList.remove('active');
                }

                currentOpenPanel = null;
                updateNavState('canvas');
                document.body.style.overflow = '';
            };

            window.closeAllMobilePanels = function () {
                const leftSidebar = document.getElementById('left-sidebar');
                const rightSidebar = document.getElementById('right-sidebar');
                const overlay = document.getElementById('mobile-overlay');

                if (leftSidebar) leftSidebar.classList.remove('mobile-panel-open');
                if (rightSidebar) rightSidebar.classList.remove('mobile-panel-open');

                closeMobileQuickPanel('camera');
                closeMobileQuickPanel('tools');

                if (overlay) overlay.classList.remove('active');

                currentOpenPanel = null;
                currentOpenQuickPanel = null;
                updateNavState('canvas');
                document.body.style.overflow = '';
            };

            // ========================================
            // GESTIONE QUICK PANELS
            // ========================================
            window.openMobileCameraActions = function () {
                if (!isMobile()) return;
                openMobileQuickPanel('camera');
            };

            window.openMobileToolsPanel = function () {
                if (!isMobile()) return;
                const panel = document.getElementById('mobile-tools-panel');
                if (!panel) return;

                const isOpen = panel.classList.contains('open');

                // Chiudi pannelli laterali se aperti (ma NON attivare overlay)
                if (currentOpenPanel) {
                    const sidePanel = document.getElementById(`${currentOpenPanel}-sidebar`);
                    if (sidePanel) sidePanel.classList.remove('mobile-panel-open');
                    const overlay = document.getElementById('mobile-overlay');
                    if (overlay) overlay.classList.remove('active');
                    currentOpenPanel = null;
                }
                // Chiudi altri quick panels (non tools)
                if (currentOpenQuickPanel && currentOpenQuickPanel !== 'tools') {
                    const oldPanel = document.getElementById(`mobile-${currentOpenQuickPanel}-panel`);
                    if (oldPanel) oldPanel.classList.remove('open');
                    currentOpenQuickPanel = null;
                }

                if (isOpen) {
                    // Toggle OFF
                    panel.classList.remove('open');
                    currentOpenQuickPanel = null;
                    updateNavState('canvas');
                    document.body.style.overflow = '';
                } else {
                    // Toggle ON - NO overlay, NO overflow block
                    panel.classList.add('open');
                    currentOpenQuickPanel = 'tools';
                    updateNavState('tools');
                    updateMobileToolsState();
                    // Nessun overlay, nessun overflow:hidden
                }
            };

            // ========================================
            // APRI PANNELLO DATI ANALISI (mobile)
            // ========================================
            window.openMobileDatiPanel = function () {
                if (!isMobile()) return;

                // Chiudi tools strip se aperto
                const toolsPanel = document.getElementById('mobile-tools-panel');
                if (toolsPanel) toolsPanel.classList.remove('open');
                if (currentOpenQuickPanel === 'tools') currentOpenQuickPanel = null;

                openMobilePanel('right');

                // Auto-espandi DATI ANALISI, collassa le altre sezioni
                setTimeout(function () {
                    const rightSidebar = document.getElementById('right-sidebar');
                    if (!rightSidebar) return;
                    const sections = rightSidebar.querySelectorAll(':scope > .section');
                    sections.forEach(function (sec) {
                        const btn = sec.querySelector('.toggle-btn');
                        const content = sec.querySelector('.section-content');
                        const icon = sec.querySelector('.icon');
                        const isDati = btn && (btn.textContent.includes('DATI') || btn.textContent.includes('Dati'));
                        sec.dataset.expanded = isDati ? 'true' : 'false';
                        if (content) content.style.display = isDati ? 'block' : 'none';
                        if (icon) icon.textContent = isDati ? '\u25bc' : '\u25ba';
                    });
                }, 80);

                updateNavState('dati');
            };

            function openMobileQuickPanel(panelId) {
                // Chiudi eventuali pannelli aperti prima
                if (currentOpenPanel) {
                    const sidePanel = document.getElementById(`${currentOpenPanel}-sidebar`);
                    if (sidePanel) sidePanel.classList.remove('mobile-panel-open');
                    currentOpenPanel = null;
                }
                if (currentOpenQuickPanel && currentOpenQuickPanel !== panelId) {
                    const oldPanel = document.getElementById(`mobile-${currentOpenQuickPanel}-panel`);
                    if (oldPanel) oldPanel.classList.remove('open');
                }

                const panel = document.getElementById(`mobile-${panelId}-panel`);
                const overlay = document.getElementById('mobile-overlay');

                if (panel) {
                    panel.classList.add('open');
                    if (overlay) overlay.classList.add('active');
                    currentOpenQuickPanel = panelId;
                    updateNavState(panelId);
                    document.body.style.overflow = 'hidden';
                }
            }

            window.closeMobileQuickPanel = function (panelId) {
                const panel = document.getElementById(`mobile-${panelId}-panel`);
                const overlay = document.getElementById('mobile-overlay');

                if (panel) {
                    panel.classList.remove('open');
                }

                if (overlay && !currentOpenPanel) {
                    overlay.classList.remove('active');
                }

                currentOpenQuickPanel = null;
                updateNavState('canvas');
                document.body.style.overflow = '';
            };

            // ========================================
            // AGGIORNA STATO TOOLS MOBILE
            // ========================================
            window.updateMobileToolsState = function () {
                const axisBtn = document.getElementById('axis-btn');
                const landmarksBtn = document.getElementById('landmarks-btn');
                const measureBtn = document.getElementById('measure-btn');

                // Sync strip buttons (nuova toolbar)
                const stripAxis = document.getElementById('mobile-strip-axis-btn');
                const stripLandmarks = document.getElementById('mobile-strip-landmarks-btn');
                const stripMeasure = document.getElementById('mobile-strip-measure-btn');

                if (stripAxis && axisBtn) stripAxis.classList.toggle('active', axisBtn.classList.contains('active'));
                if (stripLandmarks && landmarksBtn) stripLandmarks.classList.toggle('active', landmarksBtn.classList.contains('active'));
                if (stripMeasure && measureBtn) stripMeasure.classList.toggle('active', measureBtn.classList.contains('active'));

                // Compatibilit√† legacy (vecchi ID rimossi, ma defensivo)
                const mobileAxisBtn = document.getElementById('mobile-axis-btn');
                const mobileLandmarksBtn = document.getElementById('mobile-landmarks-btn');
                const mobileMeasureBtn = document.getElementById('mobile-measure-btn');
                if (mobileAxisBtn && axisBtn) mobileAxisBtn.classList.toggle('active', axisBtn.classList.contains('active'));
                if (mobileLandmarksBtn && landmarksBtn) mobileLandmarksBtn.classList.toggle('active', landmarksBtn.classList.contains('active'));
                if (mobileMeasureBtn && measureBtn) mobileMeasureBtn.classList.toggle('active', measureBtn.classList.contains('active'));
            };

            // ========================================
            // FOCUS CANVAS
            // ========================================
            window.focusCanvas = function () {
                if (!isMobile()) return;
                closeAllMobilePanels();
                updateNavState('canvas');
            };

            // ========================================
            // AGGIORNA STATO NAVIGAZIONE
            // ========================================
            function updateNavState(activePanel) {
                const navItems = document.querySelectorAll('.mobile-nav-item');
                navItems.forEach(item => {
                    const panel = item.dataset.panel;
                    item.classList.toggle('active', panel === activePanel);
                });
            }

            // ========================================
            // GESTIONE SWIPE (opzionale)
            // ========================================
            let touchStartY = 0;
            let touchEndY = 0;

            document.addEventListener('touchstart', function (e) {
                touchStartY = e.changedTouches[0].screenY;
            }, { passive: true });

            document.addEventListener('touchend', function (e) {
                touchEndY = e.changedTouches[0].screenY;
                handleSwipe();
            }, { passive: true });

            function handleSwipe() {
                const swipeThreshold = 100;
                const swipeDistance = touchStartY - touchEndY;

                // Swipe down per chiudere pannelli
                if (swipeDistance < -swipeThreshold && currentOpenPanel) {
                    closeAllMobilePanels();
                }
            }

            // ========================================
            // GESTIONE TASTO BACK (Android)
            // ========================================
            window.addEventListener('popstate', function (e) {
                if (currentOpenPanel || currentOpenQuickPanel) {
                    closeAllMobilePanels();
                    history.pushState(null, '', window.location.href);
                }
            });

            // Push stato iniziale per gestire il back
            if (isMobile()) {
                history.pushState(null, '', window.location.href);
            }

            // ========================================
            // INIZIALIZZAZIONE
            // ========================================
            document.addEventListener('DOMContentLoaded', function () {
                if (!isMobile()) return;
                console.log('üì± Mobile UI initialized');

                // Apri automaticamente il pannello Home appena il login √® completato.
                // Usiamo MutationObserver su #user-name: quando cambia da "Caricamento..."
                // a un nome reale, significa che checkAuthentication() √® riuscita.
                var userNameEl = document.getElementById('user-name');
                if (!userNameEl) return;

                var _homeOpened = false;
                var _observer = new MutationObserver(function () {
                    var name = userNameEl.textContent.trim();
                    if (!_homeOpened && name && name !== 'Caricamento...') {
                        _homeOpened = true;
                        _observer.disconnect();
                        // Piccolo delay per dare tempo al DOM di stabilizzarsi
                        setTimeout(function () {
                            if (typeof openMobileHomePanel === 'function') {
                                openMobileHomePanel();
                            }
                        }, 200);
                    }
                });
                _observer.observe(userNameEl, { childList: true, characterData: true, subtree: true });
            });

        })();
    </script>

    <!-- ========================================
         HOME PANEL MOBILE
         Pulsante Home = left-sidebar + ANTEPRIMA/DATI ANALISI + senza IMPOSTAZIONI
         ======================================== -->
    <script>
        (function () {
            'use strict';

            // Flag: impedisce che le patch di chiusura rimuovano il home-mode
            // mentre openMobileHomePanel lo sta ancora configurando
            var _settingUpHome = false;

            function _cleanupHomeMode() {
                if (_settingUpHome) return;
                var leftSidebar = document.getElementById('left-sidebar');
                if (!leftSidebar || leftSidebar.dataset.homeMode !== 'true') return;

                var rightSidebar = document.getElementById('right-sidebar');
                var panelHeader = leftSidebar.querySelector('.mobile-panel-header h2');

                leftSidebar.dataset.homeMode = '';
                leftSidebar.classList.remove('mobile-home-mode');
                if (panelHeader) panelHeader.textContent = 'Controlli';

                // Rimetti le sezioni borrowate nel right-sidebar,
                // prima del div con le tabelle nascoste
                var hiddenDiv = rightSidebar.querySelector(':scope > div[style*="display: none"]');
                var borrowed = leftSidebar.querySelectorAll('.scrollable-controls > .section.mobile-borrowed');
                borrowed.forEach(function (sec) {
                    sec.classList.remove('mobile-borrowed');
                    if (hiddenDiv) {
                        rightSidebar.insertBefore(sec, hiddenDiv);
                    } else {
                        rightSidebar.appendChild(sec);
                    }
                });
            }

            window.openMobileHomePanel = function () {
                if (window.innerWidth > 768) return;

                var leftSidebar = document.getElementById('left-sidebar');
                var rightSidebar = document.getElementById('right-sidebar');
                var panelHeader = leftSidebar.querySelector('.mobile-panel-header h2');
                var scrollable = leftSidebar.querySelector('.scrollable-controls');

                // Se home-mode era gi√† attivo (riapertura) fai cleanup prima
                if (leftSidebar.dataset.homeMode === 'true') {
                    _settingUpHome = true;
                    _cleanupHomeMode();
                    _settingUpHome = false;
                }

                _settingUpHome = true;

                // Attiva home-mode
                leftSidebar.dataset.homeMode = 'true';
                leftSidebar.classList.add('mobile-home-mode');
                if (panelHeader) panelHeader.textContent = 'Home';

                // Sposta ANTEPRIMA e DATI ANALISI dal right-sidebar in fondo al left-sidebar
                var rightSections = rightSidebar.querySelectorAll(':scope > .section');
                rightSections.forEach(function (sec) {
                    sec.classList.add('mobile-borrowed');
                    scrollable.appendChild(sec);
                });

                // Apri il pannello sinistro
                openMobilePanel('left');

                _settingUpHome = false;

                // Forza nav state su 'home' (openMobilePanel lo imposta su 'left')
                document.querySelectorAll('.mobile-nav-item').forEach(function (item) {
                    item.classList.toggle('active', item.dataset.panel === 'home');
                });
            };

            // ---- Patch funzioni di chiusura ----

            var _origCloseSingle = window.closeMobilePanel;
            window.closeMobilePanel = function (side) {
                if (side === 'left') _cleanupHomeMode();
                if (_origCloseSingle) _origCloseSingle(side);
            };

            var _origCloseAll = window.closeAllMobilePanels;
            window.closeAllMobilePanels = function () {
                _cleanupHomeMode();
                if (_origCloseAll) _origCloseAll();
            };

            // Quando il pannello Analisi (left) viene aperto normalmente,
            // assicurati di uscire dal home-mode prima
            var _origOpenPanel = window.openMobilePanel;
            window.openMobilePanel = function (side) {
                if (side === 'left' && !_settingUpHome) _cleanupHomeMode();
                if (_origOpenPanel) _origOpenPanel(side);
            };

        })();
    </script>

    <!-- Patch per bug textBaseline PRIMA di Fabric.js -->
    <script>
        // Patch preventivo per il CanvasRenderingContext2D
        if (typeof CanvasRenderingContext2D !== 'undefined') {
            const descriptor = Object.getOwnPropertyDescriptor(CanvasRenderingContext2D.prototype, 'textBaseline');
            if (descriptor && descriptor.set) {
                const originalSetter = descriptor.set;
                Object.defineProperty(CanvasRenderingContext2D.prototype, 'textBaseline', {
                    set: function (value) {
                        if (value === 'alphabetical') {
                            value = 'alphabetic';
                        }
                        return originalSetter.call(this, value);
                    },
                    get: descriptor.get,
                    enumerable: true,
                    configurable: true
                });
            }
        }
    </script>

    <!-- Fabric.js per canvas -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.0/fabric.min.js"></script>

    <!-- jsPDF per generazione PDF -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

    <script src="static/js/api-client.js"></script>
    <script src="static/js/face-detection.js"></script>
    <script src="static/js/measurements.js?v=20260120-0612"></script>
    <script src="static/js/scoring.js"></script>
    <script src="static/js/canvas.js?v=20260119-2327"></script>
    <!-- Sistema modalit√† canvas (PAN, ZOOM, SELEZIONE) -->
    <script src="static/js/canvas-modes.js"></script>
    <!-- NUOVO FILE PULITO - Correzione sopracciglia -->
    <script src="static/js/eyebrow-correction.js"></script>
    <!-- Analisi Visagistica Completa -->
    <script src="static/js/face-analysis-complete.js"></script>
    <!-- Frame Processor Unificato -->
    <script src="static/js/frame-processor.js"></script>
    <script src="static/js/main.js?v=20260225-mobilecam"></script>

    <!-- MediaPipe per face detection -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>

    <!-- ========================================
         VOICE ASSISTANT INTEGRATION
         ======================================== -->

    <!-- Voice Assistant Script -->
    <script src="static/js/voice_assistant.js?v=20260225-mobilewelcome"></script>

    <!-- Voice Widget Container (NASCOSTO - ora √® nella sidebar) -->
    <div id="voice-widget-container" style="display: none;"></div>

    <script>
        // Carica widget voice assistant (nascosto, manteniamo solo per compatibilit√† script)
        fetch('templates/voice_widget.html')
            .then(response => response.text())
            .then(html => {
                document.getElementById('voice-widget-container').innerHTML = html;
            })
            .catch(err => console.warn('Voice widget non caricato:', err));
    </script>

    <!-- Integrazione Voice Feedback nelle funzioni esistenti -->
    <script>
        // Attendi che voiceAssistant sia disponibile
        if (typeof voiceAssistant !== 'undefined') {

            // Non sovrascrivere loadImage, loadVideo, startWebcam, stopWebcam
            // perch√© ora il voice assistant simula click sui pulsanti

            // Aggiungi listener per il caricamento immagine/video
            // (il feedback vocale verr√† dato quando il file √® effettivamente caricato)
            const originalHandleFileLoad = window.handleFileLoad;
            if (originalHandleFileLoad) {
                window.handleFileLoad = function (file) {
                    const result = originalHandleFileLoad(file);
                    // Feedback vocale dopo il caricamento
                    setTimeout(() => {
                        voiceAssistant.speakMessage('image_loaded');
                    }, 500);
                    return result;
                };
            }

            // SORGENTE - Avvia Webcam
            const originalStartWebcam = window.startWebcam;
            window.startWebcam = async function () {
                if (originalStartWebcam) await originalStartWebcam();
                // Per iPhone il feedback √® gi√† gestito altrove; per la webcam locale annuncia
                if (!window.isIPhoneStreamActive) {
                    voiceAssistant.speakMessage('webcam_started');
                }
            };

            // SORGENTE - Stop Webcam
            const originalStopWebcam = window.stopWebcam;
            window.stopWebcam = async function () {
                // Salva stato iPhone prima di chiamare stop
                const wasIPhoneActive = window.isIPhoneStreamActive;

                // ‚úÖ Se iPhone era attivo, richiedi i best frames prima di fermare
                if (wasIPhoneActive && webcamWebSocket && webcamWebSocket.readyState === WebSocket.OPEN) {
                    console.log('üì± Richiesta best frames da iPhone...');
                    updateStatus('üì± Recupero migliore frame iPhone...');

                    try {
                        // Richiedi i best frames con flag final per forzare aggiornamento tabella
                        webcamWebSocket.send(JSON.stringify({
                            action: 'get_results',
                            final: true
                        }));

                        // Attendi risposta (pi√π lungo per dare tempo al server)
                        await new Promise(resolve => setTimeout(resolve, 2000));
                    } catch (error) {
                        console.error('Errore richiesta best frames:', error);
                    }
                }

                // Chiama la funzione originale
                if (originalStopWebcam) {
                    try {
                        originalStopWebcam();
                    } catch (error) {
                        console.error('Errore stopWebcam:', error);
                    }
                }

                // ‚ùå NON resettare isIPhoneStreamActive - iPhone resta connesso!
                // L'iPhone si disconnetter√† da solo o l'utente chiuder√† la pagina /camera

                voiceAssistant.speakMessage('webcam_stopped');
            };

            // TOGGLE - Asse di Simmetria
            const originalToggleAxis = window.toggleAxis;
            window.toggleAxis = function () {
                if (originalToggleAxis) originalToggleAxis();

                // Non emettere feedback vocale se siamo in modalit√† suppress
                if (window.suppressVoiceFeedback) {
                    console.log('üîá [ASSE] Feedback vocale soppresso (suppressVoiceFeedback attivo)');
                    return;
                }

                const axisBtn = document.getElementById('axis-btn');
                if (axisBtn && axisBtn.classList.contains('active')) {
                    voiceAssistant.speakMessage('axis_on');
                } else {
                    voiceAssistant.speakMessage('axis_off');
                }
            };

            // TOGGLE - Landmarks
            const originalToggleLandmarks = window.toggleLandmarks;
            window.toggleLandmarks = function () {
                if (originalToggleLandmarks) originalToggleLandmarks();

                // Non emettere feedback vocale se siamo in modalit√† suppress
                if (window.suppressVoiceFeedback) {
                    console.log('üîá [LANDMARKS] Feedback vocale soppresso (suppressVoiceFeedback attivo)');
                    return;
                }

                const landmarksBtn = document.getElementById('landmarks-btn');
                if (landmarksBtn && landmarksBtn.classList.contains('active')) {
                    voiceAssistant.speakMessage('landmarks_on');
                } else {
                    voiceAssistant.speakMessage('landmarks_off');
                }
            };

            // TOGGLE - Green Dots
            // Il feedback vocale delle differenze √® ora gestito automaticamente in main.js
            // dopo il completamento dell'analisi green dots
            const originalToggleGreenDots = window.toggleGreenDots;
            window.toggleGreenDots = function () {
                if (originalToggleGreenDots) originalToggleGreenDots();

                // Non emettere feedback vocale se siamo in modalit√† suppress
                if (window.suppressVoiceFeedback) {
                    return;
                }

                // I messaggi generici on/off non servono pi√π perch√© ora c'√® l'analisi dettagliata
                // gestita da main.js che pronuncia le differenze tra i sopraccigli
            };

            // Funzione per comando vocale "preferenza destra" - analizza spostamenti sopracciglio sinistro
            window.show_left_eyebrow_with_voice = async function () {
                // Verifica prerequisiti
                if (!window.greenDotsDetected || !window.greenDotsData?.success) {
                    if (typeof voiceAssistant !== 'undefined' && voiceAssistant.speak) {
                        voiceAssistant.speak('Prima devi rilevare i punti verdi con il pulsante green dots');
                    }
                    return;
                }

                // Apri il popup della correzione sopracciglio sinistro
                if (typeof window.showLeftEyebrow === 'function') {
                    try {
                        window.showLeftEyebrow();
                    } catch (error) {
                        if (typeof voiceAssistant !== 'undefined' && voiceAssistant.speak) {
                            voiceAssistant.speak('Errore apertura finestra correzione');
                        }
                        return;
                    }

                    // Aspetta che il popup sia aperto
                    await new Promise(resolve => setTimeout(resolve, 800));

                    // Analizza gli spostamenti dalla tabella
                    const instructions = window.analyzeLeftEyebrowMovements();

                    if (instructions) {
                        if (typeof voiceAssistant !== 'undefined' && voiceAssistant.speak) {
                            voiceAssistant.speak(instructions);
                        }
                    } else {
                        if (typeof voiceAssistant !== 'undefined' && voiceAssistant.speak) {
                            voiceAssistant.speak('Non ho trovato abbastanza dati per generare le indicazioni');
                        }
                    }
                } else {
                    if (typeof voiceAssistant !== 'undefined' && voiceAssistant.speak) {
                        voiceAssistant.speak('Funzione correzione non disponibile');
                    }
                }
            };

            // Funzione per analizzare gli spostamenti necessari del sopracciglio sinistro
            window.analyzeLeftEyebrowMovements = function () {
                console.log('üìä [MOVIMENTI SX] Analisi movimenti sopracciglio sinistro');

                const measurementsTable = document.getElementById('measurements-data');
                if (!measurementsTable) {
                    console.error('‚ùå [MOVIMENTI SX] Tabella misurazioni non trovata');
                    return null;
                }

                const rows = measurementsTable.querySelectorAll('tr[data-type="green-dots"]');
                if (rows.length === 0) {
                    console.error('‚ùå [MOVIMENTI SX] Nessun dato green dots trovato');
                    return null;
                }

                // Mappa per raccogliere i dati: punto -> {horizontal, vertical}
                const movements = {
                    'LA': { horizontal: 0, vertical: 0 },
                    'LA0': { horizontal: 0, vertical: 0 },
                    'LC1': { horizontal: 0, vertical: 0 },
                    'LB': { horizontal: 0, vertical: 0 },
                    'LC': { horizontal: 0, vertical: 0 }
                };

                rows.forEach(row => {
                    const cells = row.querySelectorAll('td');
                    if (cells.length < 2) return;

                    const label = cells[0].textContent.trim();
                    const value = cells[1].textContent.trim();

                    // Estrai le distanze e determina gli spostamenti
                    // Formato: "LA: 40.2px | RA: 40.9px RA pi√π esterno (+0.7px)"

                    // LA vs RA - Distanza Asse (orizzontale)
                    if (label.includes('LA vs RA') && label.includes('Distanza Asse')) {
                        const laMatch = value.match(/LA:\s*([\d.]+)px/);
                        const raMatch = value.match(/RA:\s*([\d.]+)px/);
                        if (laMatch && raMatch) {
                            const laDist = parseFloat(laMatch[1]);
                            const raDist = parseFloat(raMatch[1]);
                            movements['LA'].horizontal = raDist - laDist; // positivo = spostare pi√π esterno
                        }
                    }

                    // LA vs RA - Altezza (verticale)
                    if (label.includes('LA vs RA') && label.includes('Altezza')) {
                        const diff = value.match(/\(([\d.]+)px\)/);
                        if (diff) {
                            const pixels = parseFloat(diff[1]);
                            // Se RA pi√π alto, LA deve salire (negativo)
                            movements['LA'].vertical = value.includes('RA pi√π alto') ? -pixels : pixels;
                        }
                    }

                    // LA0 vs RA0 - Distanza Asse
                    if (label.includes('LA0 vs RA0') && label.includes('Distanza Asse')) {
                        const la0Match = value.match(/LA0:\s*([\d.]+)px/);
                        const ra0Match = value.match(/RA0:\s*([\d.]+)px/);
                        if (la0Match && ra0Match) {
                            const la0Dist = parseFloat(la0Match[1]);
                            const ra0Dist = parseFloat(ra0Match[1]);
                            movements['LA0'].horizontal = ra0Dist - la0Dist;
                        }
                    }

                    // LC1 vs RC1 - Distanza Asse
                    if (label.includes('LC1 vs RC1') && label.includes('Distanza Asse')) {
                        const lc1Match = value.match(/LC1:\s*([\d.]+)px/);
                        const rc1Match = value.match(/RC1:\s*([\d.]+)px/);
                        if (lc1Match && rc1Match) {
                            const lc1Dist = parseFloat(lc1Match[1]);
                            const rc1Dist = parseFloat(rc1Match[1]);
                            movements['LC1'].horizontal = rc1Dist - lc1Dist;
                        }
                    }

                    // LC1 vs RC1 - Altezza
                    if (label.includes('LC1 vs RC1') && label.includes('Altezza')) {
                        const diff = value.match(/\(([\d.]+)px\)/);
                        if (diff) {
                            const pixels = parseFloat(diff[1]);
                            movements['LC1'].vertical = value.includes('RC1 pi√π alto') ? -pixels : pixels;
                        }
                    }

                    // LB vs RB - Distanza Asse
                    if (label.includes('LB vs RB') && label.includes('Distanza Asse')) {
                        const lbMatch = value.match(/LB:\s*([\d.]+)px/);
                        const rbMatch = value.match(/RB:\s*([\d.]+)px/);
                        if (lbMatch && rbMatch) {
                            const lbDist = parseFloat(lbMatch[1]);
                            const rbDist = parseFloat(rbMatch[1]);
                            movements['LB'].horizontal = rbDist - lbDist;
                        }
                    }

                    // LB vs RB - Altezza
                    if (label.includes('LB vs RB') && label.includes('Altezza')) {
                        const diff = value.match(/\(([\d.]+)px\)/);
                        if (diff) {
                            const pixels = parseFloat(diff[1]);
                            movements['LB'].vertical = value.includes('RB pi√π alto') ? -pixels : pixels;
                        }
                    }

                    // LC vs RC - Distanza Asse
                    if (label.includes('LC vs RC') && label.includes('Distanza Asse')) {
                        const lcMatch = value.match(/LC:\s*([\d.]+)px/);
                        const rcMatch = value.match(/RC:\s*([\d.]+)px/);
                        if (lcMatch && rcMatch) {
                            const lcDist = parseFloat(lcMatch[1]);
                            const rcDist = parseFloat(rcMatch[1]);
                            movements['LC'].horizontal = rcDist - lcDist;
                        }
                    }

                    // LC vs RC - Altezza
                    if (label.includes('LC vs RC') && label.includes('Altezza')) {
                        const diff = value.match(/\(([\d.]+)px\)/);
                        if (diff) {
                            const pixels = parseFloat(diff[1]);
                            movements['LC'].vertical = value.includes('RC pi√π alto') ? -pixels : pixels;
                        }
                    }
                });

                console.log('üìè [MOVIMENTI SX] Movimenti calcolati:', movements);

                // Genera le istruzioni vocali nell'ordine richiesto: LA, LA0, LC1, LB, LC
                const pointsOrder = ['LA', 'LA0', 'LC1', 'LB', 'LC'];
                let instructions = '';
                let instructionCount = 0;

                pointsOrder.forEach((point, index) => {
                    const move = movements[point];
                    const parts = [];

                    // Formatta il nome del punto per pronuncia corretta
                    const pointSpeech = formatPointNameForSpeech(point);

                    // Movimento verticale
                    if (Math.abs(move.vertical) > 0.5) {
                        const intensity = getIntensity(Math.abs(move.vertical));
                        const direction = move.vertical < 0 ? 'pi√π in alto' : 'pi√π in basso';
                        parts.push(`${intensity}${direction}`);
                    }

                    // Movimento orizzontale
                    if (Math.abs(move.horizontal) > 0.5) {
                        const intensity = getIntensity(Math.abs(move.horizontal));
                        const direction = move.horizontal > 0 ? 'pi√π esternamente' : 'pi√π internamente';
                        parts.push(`${intensity}${direction}`);
                    }

                    // Determina il connettore in base alla posizione nell'istruzione
                    const connector = instructionCount === 0 ? 'Sposta' : 'sposta';

                    if (parts.length > 0) {
                        instructions += `${connector} ${pointSpeech} ${parts.join(' e ')}. `;
                        instructionCount++;
                    } else {
                        // Anche se non ci sono movimenti, menziona il punto
                        instructions += `${connector} ${pointSpeech} √® gi√† posizionato correttamente. `;
                        instructionCount++;
                    }
                });

                return instructions.trim() || null;
            };

            // Funzione per comando vocale "preferenza sinistra" - analizza spostamenti sopracciglio destro
            window.show_right_eyebrow_with_voice = async function () {
                console.log('üéØ [PREFERENZA SINISTRA] Inizio analisi preferenza sinistra');
                console.log('üîç [PREFERENZA SINISTRA] Verifica funzioni disponibili:', {
                    showRightEyebrow: typeof window.showRightEyebrow,
                    voiceAssistant: typeof voiceAssistant,
                    greenDotsDetected: !!window.greenDotsDetected
                });

                // Verifica prerequisiti
                if (!window.greenDotsDetected || !window.greenDotsData?.success) {
                    console.error('‚ùå [PREFERENZA SINISTRA] Green dots non rilevati');
                    if (typeof voiceAssistant !== 'undefined' && voiceAssistant.speak) {
                        voiceAssistant.speak('Prima devi rilevare i punti verdi con il pulsante green dots');
                    }
                    return;
                }

                // Step 1: Apri il popup della correzione sopracciglio destro
                if (typeof window.showRightEyebrow === 'function') {
                    console.log('üìä [PREFERENZA SINISTRA] Apertura popup correzione...');
                    try {
                        window.showRightEyebrow();
                        console.log('‚úÖ [PREFERENZA SINISTRA] Popup aperto con successo');
                    } catch (error) {
                        console.error('‚ùå [PREFERENZA SINISTRA] Errore apertura popup:', error);
                        if (typeof voiceAssistant !== 'undefined' && voiceAssistant.speak) {
                            voiceAssistant.speak('Errore apertura finestra correzione');
                        }
                        return;
                    }

                    // Step 2: Aspetta che il popup sia aperto (breve delay)
                    await new Promise(resolve => setTimeout(resolve, 800));

                    // Step 3: Analizza gli spostamenti dalla tabella
                    console.log('üìè [PREFERENZA SINISTRA] Analisi spostamenti dalla tabella...');
                    const instructions = window.analyzeRightEyebrowMovements();

                    if (instructions) {
                        console.log('üîä [PREFERENZA SINISTRA] Pronuncia indicazioni:', instructions);
                        if (typeof voiceAssistant !== 'undefined' && voiceAssistant.speak) {
                            voiceAssistant.speak(instructions);
                        }
                    } else {
                        console.error('‚ùå [PREFERENZA SINISTRA] Impossibile generare indicazioni');
                        if (typeof voiceAssistant !== 'undefined' && voiceAssistant.speak) {
                            voiceAssistant.speak('Non ho trovato abbastanza dati per generare le indicazioni');
                        }
                    }
                } else {
                    console.error('‚ùå [PREFERENZA SINISTRA] Funzione showRightEyebrow non disponibile');
                    console.error('    window.showRightEyebrow:', window.showRightEyebrow);
                    if (typeof voiceAssistant !== 'undefined' && voiceAssistant.speak) {
                        voiceAssistant.speak('Funzione correzione non disponibile');
                    }
                }
            };

            // Funzione per analizzare gli spostamenti necessari del sopracciglio destro
            window.analyzeRightEyebrowMovements = function () {
                console.log('üìä [MOVIMENTI DX] Analisi movimenti sopracciglio destro');

                const measurementsTable = document.getElementById('measurements-data');
                if (!measurementsTable) {
                    console.error('‚ùå [MOVIMENTI DX] Tabella misurazioni non trovata');
                    return null;
                }

                const rows = measurementsTable.querySelectorAll('tr[data-type="green-dots"]');
                if (rows.length === 0) {
                    console.error('‚ùå [MOVIMENTI DX] Nessun dato green dots trovato');
                    return null;
                }

                // Mappa per raccogliere i dati: punto -> {horizontal, vertical}
                const movements = {
                    'RA': { horizontal: 0, vertical: 0 },
                    'RA0': { horizontal: 0, vertical: 0 },
                    'RC1': { horizontal: 0, vertical: 0 },
                    'RB': { horizontal: 0, vertical: 0 },
                    'RC': { horizontal: 0, vertical: 0 }
                };

                rows.forEach(row => {
                    const cells = row.querySelectorAll('td');
                    if (cells.length < 2) return;

                    const label = cells[0].textContent.trim();
                    const value = cells[1].textContent.trim();

                    // RA vs LA - Distanza Asse (orizzontale) - inverso rispetto a LA
                    if (label.includes('LA vs RA') && label.includes('Distanza Asse')) {
                        const laMatch = value.match(/LA:\s*([\d.]+)px/);
                        const raMatch = value.match(/RA:\s*([\d.]+)px/);
                        if (laMatch && raMatch) {
                            const laDist = parseFloat(laMatch[1]);
                            const raDist = parseFloat(raMatch[1]);
                            movements['RA'].horizontal = laDist - raDist; // positivo = spostare pi√π esterno
                        }
                    }

                    // RA vs LA - Altezza (verticale)
                    if (label.includes('LA vs RA') && label.includes('Altezza')) {
                        const diff = value.match(/\(([\d.]+)px\)/);
                        if (diff) {
                            const pixels = parseFloat(diff[1]);
                            // Se LA pi√π alto, RA deve salire (negativo)
                            movements['RA'].vertical = value.includes('LA pi√π alto') ? -pixels : pixels;
                        }
                    }

                    // RA0 vs LA0 - Distanza Asse
                    if (label.includes('LA0 vs RA0') && label.includes('Distanza Asse')) {
                        const la0Match = value.match(/LA0:\s*([\d.]+)px/);
                        const ra0Match = value.match(/RA0:\s*([\d.]+)px/);
                        if (la0Match && ra0Match) {
                            const la0Dist = parseFloat(la0Match[1]);
                            const ra0Dist = parseFloat(ra0Match[1]);
                            movements['RA0'].horizontal = la0Dist - ra0Dist;
                        }
                    }

                    // RC1 vs LC1 - Distanza Asse
                    if (label.includes('LC1 vs RC1') && label.includes('Distanza Asse')) {
                        const lc1Match = value.match(/LC1:\s*([\d.]+)px/);
                        const rc1Match = value.match(/RC1:\s*([\d.]+)px/);
                        if (lc1Match && rc1Match) {
                            const lc1Dist = parseFloat(lc1Match[1]);
                            const rc1Dist = parseFloat(rc1Match[1]);
                            movements['RC1'].horizontal = lc1Dist - rc1Dist;
                        }
                    }

                    // RC1 vs LC1 - Altezza
                    if (label.includes('LC1 vs RC1') && label.includes('Altezza')) {
                        const diff = value.match(/\(([\d.]+)px\)/);
                        if (diff) {
                            const pixels = parseFloat(diff[1]);
                            movements['RC1'].vertical = value.includes('LC1 pi√π alto') ? -pixels : pixels;
                        }
                    }

                    // RB vs LB - Distanza Asse
                    if (label.includes('LB vs RB') && label.includes('Distanza Asse')) {
                        const lbMatch = value.match(/LB:\s*([\d.]+)px/);
                        const rbMatch = value.match(/RB:\s*([\d.]+)px/);
                        if (lbMatch && rbMatch) {
                            const lbDist = parseFloat(lbMatch[1]);
                            const rbDist = parseFloat(rbMatch[1]);
                            movements['RB'].horizontal = lbDist - rbDist;
                        }
                    }

                    // RB vs LB - Altezza
                    if (label.includes('LB vs RB') && label.includes('Altezza')) {
                        const diff = value.match(/\(([\d.]+)px\)/);
                        if (diff) {
                            const pixels = parseFloat(diff[1]);
                            movements['RB'].vertical = value.includes('LB pi√π alto') ? -pixels : pixels;
                        }
                    }

                    // RC vs LC - Distanza Asse
                    if (label.includes('LC vs RC') && label.includes('Distanza Asse')) {
                        const lcMatch = value.match(/LC:\s*([\d.]+)px/);
                        const rcMatch = value.match(/RC:\s*([\d.]+)px/);
                        if (lcMatch && rcMatch) {
                            const lcDist = parseFloat(lcMatch[1]);
                            const rcDist = parseFloat(rcMatch[1]);
                            movements['RC'].horizontal = lcDist - rcDist;
                        }
                    }

                    // RC vs LC - Altezza
                    if (label.includes('LC vs RC') && label.includes('Altezza')) {
                        const diff = value.match(/\(([\d.]+)px\)/);
                        if (diff) {
                            const pixels = parseFloat(diff[1]);
                            movements['RC'].vertical = value.includes('LC pi√π alto') ? -pixels : pixels;
                        }
                    }
                });

                console.log('üìè [MOVIMENTI DX] Movimenti calcolati:', movements);

                // Genera le istruzioni vocali nell'ordine richiesto: RA, RA0, RC1, RB, RC
                const pointsOrder = ['RA', 'RA0', 'RC1', 'RB', 'RC'];
                let instructions = '';
                let instructionCount = 0;

                pointsOrder.forEach((point, index) => {
                    const move = movements[point];
                    const parts = [];

                    // Formatta il nome del punto per pronuncia corretta
                    const pointSpeech = formatPointNameForSpeech(point);

                    // Movimento verticale
                    if (Math.abs(move.vertical) > 0.5) {
                        const intensity = getIntensity(Math.abs(move.vertical));
                        const direction = move.vertical < 0 ? 'pi√π in alto' : 'pi√π in basso';
                        parts.push(`${intensity}${direction}`);
                    }

                    // Movimento orizzontale
                    if (Math.abs(move.horizontal) > 0.5) {
                        const intensity = getIntensity(Math.abs(move.horizontal));
                        const direction = move.horizontal > 0 ? 'pi√π esternamente' : 'pi√π internamente';
                        parts.push(`${intensity}${direction}`);
                    }

                    // Determina il connettore in base alla posizione nell'istruzione
                    const connector = instructionCount === 0 ? 'Sposta' : 'sposta';

                    if (parts.length > 0) {
                        instructions += `${connector} ${pointSpeech} ${parts.join(' e ')}. `;
                        instructionCount++;
                    } else {
                        // Anche se non ci sono movimenti, menziona il punto
                        instructions += `${connector} ${pointSpeech} √® gi√† posizionato correttamente. `;
                        instructionCount++;
                    }
                });

                return instructions.trim() || null;
            };

            // Funzione helper per determinare l'intensit√† dello spostamento
            function getIntensity(pixels) {
                if (pixels < 2) return '';
                if (pixels < 5) return 'leggermente ';
                if (pixels < 10) return '';
                if (pixels < 20) return 'molto ';
                return 'molto ';
            }

            // Funzione helper per formattare i nomi dei punti per pronuncia corretta
            function formatPointNameForSpeech(pointName) {
                // Mappa caratteri a pronuncia italiana rallentata
                const letterMap = {
                    'L': 'Elle',      // Pronuncia normale senza accenti
                    'R': 'Erre',
                    'A': 'A',
                    'B': 'Bi',
                    'C': 'Ci',
                    '0': 'Zero',
                    '1': 'Uno'
                };

                // Separa ogni carattere del punto con pause per rallentare
                const letters = pointName.split('').map(char => letterMap[char] || char);

                // Aggiunge piccola pausa prima e dopo, e virgole tra le lettere per rallentare
                return '. ' + letters.join(', ') + ' .';
            }

            // === GESTIONE CAMERA IPHONE VIA BROWSER ===

            // ‚úÖ Variabile globale per tracciare stato iPhone reale
            window.isIPhoneStreamActive = false;

            // Aggiorna il QR code (forza refresh)
            window.refreshQRCode = function () {
                const qrImg = document.getElementById('qr-code-img');
                if (qrImg) {
                    // Aggiungi timestamp per forzare refresh
                    qrImg.src = '/api/qrcode.png?t=' + Date.now();
                }
            };

            // Aggiorna stato connessione iPhone nell'UI
            function updateIPhoneStatus(connected, deviceId) {
                const container = document.getElementById('iphone-status-container');
                const icon = document.getElementById('iphone-status-icon');
                const text = document.getElementById('iphone-status-text');
                const deviceInfo = document.getElementById('iphone-device-info');
                const deviceIdSpan = document.getElementById('iphone-device-id');

                if (connected) {
                    container.style.background = '#d4edda';
                    container.style.borderLeftColor = '#28a745';
                    icon.textContent = 'Connesso';
                    text.textContent = 'iPhone connesso e streaming attivo';
                    text.style.color = '#155724';
                    deviceInfo.style.display = 'block';
                    deviceIdSpan.textContent = deviceId || '--';

                    showToast('iPhone connesso!', 'success');

                    // ‚úÖ Apri automaticamente la sezione webcam per mostrare i frame iPhone
                    if (typeof openWebcamSection === 'function') {
                        openWebcamSection();
                    }

                    if (typeof voiceAssistant !== 'undefined' && voiceAssistant.speak) {
                        voiceAssistant.speak('iPhone connesso. Lo streaming e attivo.');
                    }
                } else {
                    container.style.background = '#fff3cd';
                    container.style.borderLeftColor = '#ffc107';
                    icon.textContent = 'In attesa';
                    text.textContent = 'Nessun iPhone connesso';
                    text.style.color = '#856404';
                    deviceInfo.style.display = 'none';
                }
            }


            // Cache per preview fluido
            let _previewCanvas = null;
            let _previewCtx = null;
            let _previewImg = new Image();
            let _previewInitialized = false;
            // Canvas ad alta risoluzione nascosto, usato dal fullscreen loop
            let _fullresCanvas = null;
            let _fullresCtx = null;

            // Funzione per rendere frame iPhone nel canvas preview - OTTIMIZZATA
            window.renderIPhoneFramePreview = function (frameData) {
                if (!frameData) return;

                // Cache elementi DOM (una sola volta)
                if (!_previewCanvas) {
                    _previewCanvas = document.getElementById('webcam-preview-canvas');
                    if (!_previewCanvas) return;
                    _previewCtx = _previewCanvas.getContext('2d', { alpha: false });
                }

                // Canvas fullres nascosto per il fullscreen loop (√† risoluzione originale)
                if (!_fullresCanvas) {
                    _fullresCanvas = document.createElement('canvas');
                    _fullresCanvas.id = 'iphone-fullres-canvas';
                    _fullresCanvas.style.display = 'none';
                    document.body.appendChild(_fullresCanvas);
                    _fullresCtx = _fullresCanvas.getContext('2d', { alpha: false });
                }

                // Usa sempre lo stesso oggetto Image per evitare allocazioni
                _previewImg.onload = function () {
                    // Aggiorna canvas fullres alla risoluzione originale del frame
                    const nw = _previewImg.naturalWidth || _previewImg.width;
                    const nh = _previewImg.naturalHeight || _previewImg.height;
                    if (nw > 0 && nh > 0) {
                        if (_fullresCanvas.width !== nw || _fullresCanvas.height !== nh) {
                            _fullresCanvas.width = nw;
                            _fullresCanvas.height = nh;
                        }
                        _fullresCtx.drawImage(_previewImg, 0, 0, nw, nh);
                    }

                    // Inizializza dimensioni canvas sidebar solo una volta
                    if (!_previewInitialized) {
                        // Dimensioni fisse piccole per anteprima sidebar (240px larghezza)
                        const maxWidth = 240;
                        const aspectRatio = _previewImg.width / _previewImg.height;
                        _previewCanvas.width = maxWidth;
                        _previewCanvas.height = Math.round(maxWidth / aspectRatio);
                        _previewCanvas.style.width = maxWidth + 'px';
                        _previewCanvas.style.height = _previewCanvas.height + 'px';
                        _previewCanvas.style.display = 'block';
                        _previewCanvas.classList.add('active');
                        _previewInitialized = true;
                    }

                    // Disegna frame scalato sul canvas sidebar
                    _previewCtx.drawImage(_previewImg, 0, 0, _previewCanvas.width, _previewCanvas.height);
                };
                _previewImg.src = 'data:image/jpeg;base64,' + frameData;
            };

            // Reset preview cache quando si ferma webcam
            window.resetPreviewCache = function () {
                _previewInitialized = false;
            };

            // ‚úÖ AudioContext singleton per evitare errori multipli
            window.audioContextInstance = null;

            // ‚úÖ Funzione per riprodurre beep quando score √® alto
            window.playBeep = function (score) {
                try {
                    // Usa singleton AudioContext
                    if (!window.audioContextInstance) {
                        window.audioContextInstance = new (window.AudioContext || window.webkitAudioContext)();
                    }

                    const audioContext = window.audioContextInstance;
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();

                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);

                    // 1000 Hz se score ‚â• 97, altrimenti 800 Hz
                    oscillator.frequency.value = (score >= 97) ? 1000 : 800;
                    oscillator.type = 'sine';

                    gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);

                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.2);
                } catch (e) {
                    console.error('Errore riproduzione beep:', e);
                }
            };

            // ‚úÖ Popola tabella DATI ANALISI con misurazioni dal frame
            // Throttle: viene chiamata al massimo una volta per sessione
            window._populateTableCalled = false;
            async function populateTableFromLandmarks(landmarks, frameBase64) {
                if (window._populateTableCalled) return;  // una sola volta per sessione
                window._populateTableCalled = true;
                try {
                    console.log('üìä Popolamento tabella da landmarks iPhone...');

                    // Chiama API per ottenere misurazioni
                    const response = await fetch('/api/canvas-analysis', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            image: frameBase64
                        })
                    });

                    if (!response.ok) {
                        console.warn('‚ö†Ô∏è Errore API analisi:', response.status);
                        return;
                    }

                    const analysisData = await response.json();
                    console.log('‚úÖ Dati analisi ricevuti:', analysisData);

                    // Apri sezione DATI ANALISI se chiusa
                    if (typeof openUnifiedAnalysisSection === 'function') {
                        openUnifiedAnalysisSection();
                    }

                    // Switcha al tab Measurements
                    if (typeof switchUnifiedTab === 'function') {
                        switchUnifiedTab('measurements');
                    }

                    // Aggiungi misurazioni alla tabella usando funzione esistente
                    if (typeof addMeasurementToTable === 'function' && analysisData.measurements) {
                        analysisData.measurements.forEach(m => {
                            addMeasurementToTable(m.name, m.value, m.unit);
                        });
                    }

                } catch (error) {
                    console.error('‚ùå Errore popolamento tabella:', error);
                }
            }

            // ‚ùå RIMOSSA FUNZIONE DUPLICATA renderIPhoneFramePreview (era definita 2 volte)

            // ‚ùå RIMOSSA registerDesktopForIPhoneNotifications - duplicato di main.js
            // La registrazione desktop avviene automaticamente in connectWebcamWebSocket()

            // ‚úÖ Tracciamento miglior score iPhone
            window.bestIPhoneScore = 0;

            // Coaching posa vocale per PC (throttle 2s, silenzio 4s all'avvio stream)
            let _poseCoachLastTime = 0;
            const _POSE_COACH_INTERVAL = 2000;
            let _poseCoachHighScoreSaid = false;
            let _poseCoachStreamStartTime = 0; // reset ad ogni connessione iPhone
            let _poseCoachLastMsg = '';         // deduplicazione: non ripetere stessa frase
            const _POSE_COACH_STARTUP_SILENCE = 4000; // ms di silenzio dopo avvio stream

            function updatePoseCoachingPC(data) {
                if (!data || typeof voiceAssistant === 'undefined' || voiceAssistant.isMuted) return;
                const now = Date.now();
                // Silenzio iniziale: non disturbare nei primi secondi dopo il collegamento
                if (_poseCoachStreamStartTime > 0 && now - _poseCoachStreamStartTime < _POSE_COACH_STARTUP_SILENCE) return;
                // Throttle globale
                if (now - _poseCoachLastTime < _POSE_COACH_INTERVAL) return;

                const faces = data.faces_detected || 0;
                const pose = data.pose || data.pose_angles;
                const sb = data.score_breakdown || {};
                const score = data.score || data.current_score || 0;

                let msg = null;

                if (faces === 0) {
                    msg = 'Nessun viso rilevato. Posizionati davanti alla fotocamera.';
                } else if (pose) {
                    const faceRatio = sb.face_ratio || 0;
                    const yaw = pose.yaw || 0;
                    const pitch = pose.pitch || 0;
                    const roll = pose.roll || 0;
                    const absYaw = Math.abs(yaw);
                    const absPitch = Math.abs(pitch);
                    const absRoll = Math.abs(roll);

                    if (faceRatio > 0 && faceRatio < 0.18) {
                        msg = 'Avvicinati alla fotocamera.';
                    } else if (faceRatio > 0.58) {
                        msg = 'Allontanati un po\' dalla fotocamera.';
                    } else if (absYaw >= 14 && absYaw >= absPitch && absYaw >= absRoll) {
                        msg = yaw > 0 ? 'G√¨rati leggermente a sinistra.' : 'G√¨rati leggermente a destra.';
                    } else if (absPitch >= 12 && absPitch >= absRoll) {
                        msg = pitch > 0 ? 'Abbassa leggermente il mento.' : 'Alza leggermente il mento.';
                    } else if (absRoll >= 14) {
                        msg = 'Raddrizza la testa.';
                    } else if (score >= 92 && !_poseCoachHighScoreSaid) {
                        _poseCoachHighScoreSaid = true;
                        msg = 'Ottimo! Mantieni questa posizione.';
                    } else if (score < 85) {
                        _poseCoachHighScoreSaid = false;
                    }
                }

                // Pronuncia solo se messaggio nuovo rispetto all'ultimo
                if (msg && msg !== _poseCoachLastMsg) {
                    _poseCoachLastTime = now;
                    _poseCoachLastMsg = msg;
                    voiceAssistant.speakCoach(msg);
                } else if (!msg) {
                    // Posa OK: resetta l'ultimo messaggio per permettere future ripetizioni
                    _poseCoachLastMsg = '';
                }
            }

            // Handler per messaggi iPhone dal WebSocket
            function handleIPhoneWebSocketMessage(data) {
                if (data.action === 'iphone_connected') {
                    window.isIPhoneStreamActive = true;
                    window.bestIPhoneScore = 0;
                    window._populateTableCalled = false;
                    _poseCoachStreamStartTime = Date.now(); // Avvia finestra di silenzio iniziale
                    _poseCoachLastMsg = '';                 // Reset dedup per nuova sessione
                    _poseCoachHighScoreSaid = false;
                    updateIPhoneStatus(true, data.deviceIdShort);
                    if (typeof showToast === 'function') {
                        showToast('iPhone connesso - Avvio streaming automatico...', 'success');
                    }
                    // Avvia webcam automaticamente senza attendere il pulsante
                    if (!window.isWebcamActive && typeof startWebcam === 'function') {
                        setTimeout(() => startWebcam(), 300);
                    }
                } else if (data.action === 'iphone_disconnected') {
                    window.isIPhoneStreamActive = false;
                    window.bestIPhoneScore = 0;
                    updateIPhoneStatus(false);
                } else if (data.action === 'iphone_frame_processed') {
                    window.isIPhoneStreamActive = true;

                    if (data.frame_data && typeof window.renderIPhoneFramePreview === 'function') {
                        window.renderIPhoneFramePreview(data.frame_data);
                    }

                    if (typeof updateFrameProcessingStats === 'function') {
                        updateFrameProcessingStats(data);
                    }

                    // Coaching posa vocale sul PC
                    updatePoseCoachingPC(data);

                    const score = data.score || 0;
                    const HIGH_SCORE_THRESHOLD = 92;

                    // Aggiorna canvas solo se score migliora rispetto al miglior score finora
                    if (score >= HIGH_SCORE_THRESHOLD && score > window.bestIPhoneScore) {
                        window.bestIPhoneScore = score;

                        if (typeof playBeep === 'function') {
                            playBeep(score);
                        }

                        if (data.frame_data) {
                            const img = new Image();
                            img.onload = function () {
                                if (typeof displayImageOnCanvas === 'function') {
                                    displayImageOnCanvas(img);
                                }
                                if (data.landmarks) {
                                    window.currentLandmarks = data.landmarks;
                                    if (typeof updateCanvasDisplay === 'function') {
                                        updateCanvasDisplay();
                                    }
                                    populateTableFromLandmarks(data.landmarks, data.frame_data);
                                }
                            };
                            img.src = 'data:image/jpeg;base64,' + data.frame_data;
                        }
                    }

                    // Richiedi best frames ogni 10 frame (ridotto da 5)
                    if (data.total_frames_collected && data.total_frames_collected > 0) {
                        const shouldRequest = window.bestIPhoneScore === 0 ||
                            (score > window.bestIPhoneScore + 0.5) ||
                            (data.total_frames_collected % 5 === 0);  // ogni 5 frame come webcam PC

                        if (shouldRequest && typeof requestBestFramesUpdate === 'function') {
                            requestBestFramesUpdate();
                        }
                    }
                } else if (data.action === 'desktop_registered') {
                    if (data.connected_iphones.length > 0) {
                        updateIPhoneStatus(true, data.connected_iphones[0].deviceIdShort);
                        window.isIPhoneStreamActive = true;
                        // iPhone gi√† connesso al ricaricamento pagina ‚Üí avvio automatico
                        if (!window.isWebcamActive && typeof startWebcam === 'function') {
                            setTimeout(() => startWebcam(), 300);
                        }
                    }
                } else if (data.action === 'iphone_status') {
                    if (data.connected_count > 0 && data.devices.length > 0) {
                        updateIPhoneStatus(true, data.devices[0].deviceIdShort);
                        window.isIPhoneStreamActive = true;
                        // iPhone gi√† connesso ‚Üí avvio automatico
                        if (!window.isWebcamActive && typeof startWebcam === 'function') {
                            setTimeout(() => startWebcam(), 300);
                        }
                    } else {
                        updateIPhoneStatus(false);
                    }
                }
                // ‚ö†Ô∏è NOTA: best_frames_result e results_ready NON vengono gestiti qui
                // perch√© devono essere processati da main.js handleResultsReady()
                // che chiama updateDebugTable(), openUnifiedAnalysisSection() e switchUnifiedTab('debug')
            }

            // ‚ùå RIMOSSO WRAPPER DUPLICATO - handleWebSocketMessage gi√† gestito in main.js
            // Il main.js delega automaticamente i messaggi iPhone a handleIPhoneWebSocketMessage

            // Inizializza sistema iPhone al caricamento pagina
            document.addEventListener('DOMContentLoaded', function () {
                // ‚úÖ Reset stato iPhone all'avvio (assume nessun iPhone connesso)
                updateIPhoneStatus(false);

                // ‚úÖ CREA SUBITO IL WEBSOCKET per ricevere notifiche iPhone
                // (anche se la webcam non √® attiva)
                setTimeout(async function () {
                    if (typeof connectWebcamWebSocket !== 'undefined') {
                        try {
                            await connectWebcamWebSocket();
                            console.log('‚úÖ WebSocket desktop connesso per notifiche iPhone');

                            // ‚ùå RIMOSSA registrazione duplicata - gi√† fatta in main.js connectWebcamWebSocket()

                            // Richiedi stato iPhone attuale
                            if (webcamWebSocket && webcamWebSocket.readyState === WebSocket.OPEN) {
                                webcamWebSocket.send(JSON.stringify({
                                    action: 'get_iphone_status'
                                }));
                            }
                        } catch (err) {
                            console.error('‚ùå Errore connessione WebSocket desktop:', err);
                        }
                    }
                }, 1000);
            });

            // Funzione per analizzare la progettazione sopraccigliare
            window.analyze_eyebrow_design = async function () {
                console.log('üîç [ANALISI PROGETTAZIONE] Inizio analisi progettazione sopraccigliare');

                // Flag per disabilitare feedback vocali automatici durante questa operazione
                window.suppressVoiceFeedback = true;

                // Step 0: Verifica se ci sono gi√† dati disponibili nella tabella
                const measurementsTable = document.getElementById('measurements-data');
                let existingGreenDotsRows = measurementsTable ? measurementsTable.querySelectorAll('tr[data-type="green-dots"]') : [];

                console.log('üìä [ANALISI PROGETTAZIONE] Righe green dots esistenti:', existingGreenDotsRows.length);

                // Step 1: Se non ci sono dati o il pulsante non √® attivo, esegui analisi green dots
                const greenDotsBtn = document.getElementById('green-dots-btn');
                const needsAnalysis = existingGreenDotsRows.length === 0 ||
                    !greenDotsBtn ||
                    !greenDotsBtn.classList.contains('active');

                if (needsAnalysis) {
                    console.log('üü¢ [ANALISI PROGETTAZIONE] Esecuzione analisi green dots necessaria...');

                    // Attiva il pulsante se non lo √® gi√†
                    if (greenDotsBtn && !greenDotsBtn.classList.contains('active')) {
                        greenDotsBtn.classList.add('active');
                        console.log('‚úÖ [ANALISI PROGETTAZIONE] Pulsante green dots attivato');
                    }

                    // Chiama direttamente detectGreenDots() invece di toggleGreenDots()
                    if (typeof detectGreenDots === 'function') {
                        console.log('üîÑ [ANALISI PROGETTAZIONE] Chiamata detectGreenDots()...');
                        await detectGreenDots();
                    } else {
                        console.error('‚ùå [ANALISI PROGETTAZIONE] detectGreenDots non disponibile');
                        window.suppressVoiceFeedback = false;
                        if (typeof voiceAssistant !== 'undefined' && voiceAssistant.speak) {
                            voiceAssistant.speak('Errore: funzione green dots non disponibile');
                        }
                        return;
                    }

                    // Step 2: Aspetta che i risultati siano disponibili (max 5 secondi)
                    console.log('‚è≥ [ANALISI PROGETTAZIONE] Attesa risultati green dots...');
                    let attempts = 0;
                    const maxAttempts = 50; // 5 secondi con check ogni 100ms

                    const waitForResults = () => {
                        return new Promise((resolve) => {
                            const checkResults = () => {
                                const table = document.getElementById('measurements-data');
                                const rows = table ? table.querySelectorAll('tr[data-type="green-dots"]') : [];

                                console.log(`üîÑ [ANALISI PROGETTAZIONE] Check ${attempts + 1}/${maxAttempts}: trovate ${rows.length} righe green dots`);

                                if (rows.length > 0 || attempts >= maxAttempts) {
                                    resolve(rows.length > 0);
                                } else {
                                    attempts++;
                                    setTimeout(checkResults, 100);
                                }
                            };
                            checkResults();
                        });
                    };

                    const resultsAvailable = await waitForResults();

                    // Riabilita feedback vocali
                    window.suppressVoiceFeedback = false;

                    if (!resultsAvailable) {
                        console.error('‚ùå [ANALISI PROGETTAZIONE] Timeout: risultati green dots non disponibili');
                        if (typeof voiceAssistant !== 'undefined' && voiceAssistant.speak) {
                            voiceAssistant.speak('Non sono riuscita a ottenere i risultati dell\'analisi');
                        }
                        return;
                    }
                } else {
                    console.log('‚úÖ [ANALISI PROGETTAZIONE] Dati gi√† disponibili, uso quelli esistenti');
                    // Riabilita feedback vocali subito
                    window.suppressVoiceFeedback = false;
                }

                // Step 3: Analizza i dati dalla tabella
                console.log('üìä [ANALISI PROGETTAZIONE] Analisi dati dalla tabella...');
                const feedback = analyzeEyebrowDesignFromTable();

                if (feedback) {
                    console.log('‚úÖ [ANALISI PROGETTAZIONE] Feedback generato:', feedback);
                    // Step 4: L'assistente pronuncia il feedback usando speak() per testo personalizzato
                    if (typeof voiceAssistant !== 'undefined' && voiceAssistant.speak) {
                        console.log('üîä [ANALISI PROGETTAZIONE] Invio feedback a voice assistant');
                        voiceAssistant.speak(feedback);
                    } else {
                        console.error('‚ùå [ANALISI PROGETTAZIONE] voiceAssistant.speak non disponibile');
                    }
                } else {
                    console.error('‚ùå [ANALISI PROGETTAZIONE] Impossibile generare feedback');
                    if (typeof voiceAssistant !== 'undefined' && voiceAssistant.speak) {
                        voiceAssistant.speak('Non ho trovato abbastanza dati per l\'analisi');
                    }
                }
            };

            // Funzione per analizzare i dati dalla tabella misurazioni
            window.analyzeEyebrowDesignFromTable = function () {
                console.log('üìä Analisi dati tabella misurazioni');

                const measurementsTable = document.getElementById('measurements-data');
                if (!measurementsTable) {
                    console.error('‚ùå Tabella misurazioni non trovata');
                    return null;
                }

                const rows = measurementsTable.querySelectorAll('tr[data-type="green-dots"]');
                if (rows.length === 0) {
                    console.error('‚ùå Nessun dato green dots trovato');
                    return null;
                }

                console.log(`üìã Trovate ${rows.length} righe di dati green dots`);

                // Estrai i dati rilevanti
                let externalEyebrow = null; // Quale sopracciglio inizia pi√π esternamente (punto A pi√π lontano dall'asse)
                let higherEyebrow = null; // Quale sopracciglio √® pi√π alto (punto C1)
                let longerTail = null; // Quale ha la coda pi√π lunga (punto B)
                let thickerEyebrow = null; // Quale √® pi√π spesso (area)

                rows.forEach(row => {
                    const cells = row.querySelectorAll('td');
                    if (cells.length < 2) return;

                    const label = cells[0].textContent.trim();
                    const value = cells[1].textContent.trim();

                    console.log(`   üìù ${label}: ${value}`);

                    // Analisi punto A (distanza dall'asse) - Il punto PI√ô LONTANO inizia pi√π esternamente
                    if (label.includes('LA vs RA') && label.includes('Distanza Asse')) {
                        // Cerca "LA pi√π esterno" o "RA pi√π esterno" nel nuovo formato
                        if (value.includes('LA pi√π esterno')) {
                            externalEyebrow = 'sinistro'; // LA pi√π lontano = sopracciglio sinistro inizia pi√π esternamente
                        } else if (value.includes('RA pi√π esterno')) {
                            externalEyebrow = 'destro'; // RA pi√π lontano = sopracciglio destro inizia pi√π esternamente
                        }
                    }

                    // Analisi punto C1 (altezza)
                    if (label.includes('LC1 vs RC1') && label.includes('Altezza')) {
                        if (value.includes('LC1')) {
                            higherEyebrow = 'sinistro';
                        } else if (value.includes('RC1')) {
                            higherEyebrow = 'destro';
                        }
                    }

                    // Analisi punto B (coda pi√π lunga) - Il punto PI√ô LONTANO dall'asse ha la coda pi√π lunga
                    if (label.includes('LB vs RB') && label.includes('Distanza Asse')) {
                        // Cerca "LB pi√π esterno" o "RB pi√π esterno" nel nuovo formato
                        if (value.includes('LB pi√π esterno')) {
                            longerTail = 'sinistro'; // LB pi√π lontano = coda sinistra pi√π lunga
                        } else if (value.includes('RB pi√π esterno')) {
                            longerTail = 'destro'; // RB pi√π lontano = coda destra pi√π lunga
                        }
                    }

                    // Analisi area (spessore)
                    if ((label.includes('Poligono Sinistro') || label.includes('Poligono Destro')) && value.includes('MAGGIORE')) {
                        if (label.includes('Sinistro')) {
                            thickerEyebrow = 'sinistro';
                        } else if (label.includes('Destro')) {
                            thickerEyebrow = 'destro';
                        }
                    }
                });

                console.log('üîç Risultati analisi:', {
                    externalEyebrow,
                    higherEyebrow,
                    longerTail,
                    thickerEyebrow
                });

                // Genera il feedback testuale
                if (!externalEyebrow || !higherEyebrow || !longerTail || !thickerEyebrow) {
                    console.warn('‚ö†Ô∏è Alcuni dati mancanti per generare feedback completo');
                }

                // Costruisci la frase seguendo esattamente il formato richiesto
                let feedback = '';

                // 1. Quale sopracciglio inizia pi√π esternamente (punto A pi√π lontano dall'asse)
                if (externalEyebrow === 'destro') {
                    feedback += 'Il sopracciglio alla tua destra inizia pi√π esternamente. ';
                } else if (externalEyebrow === 'sinistro') {
                    feedback += 'Il sopracciglio alla tua sinistra inizia pi√π esternamente. ';
                }

                // 2. Quale sopracciglio √® pi√π alto (C1)
                if (higherEyebrow === 'sinistro') {
                    feedback += 'Il sopracciglio alla tua sinistra √® pi√π alto rispetto l\'altro. ';
                } else if (higherEyebrow === 'destro') {
                    feedback += 'Il sopracciglio alla tua destra √® pi√π alto rispetto l\'altro. ';
                }

                // 3. Quale ha la coda pi√π lunga (B)
                if (longerTail === 'sinistro') {
                    feedback += 'La coda del sopracciglio alla tua sinistra √® pi√π lunga. ';
                } else if (longerTail === 'destro') {
                    feedback += 'La coda del sopracciglio alla tua destra √® pi√π lunga. ';
                }

                // 4. Quale √® pi√π spesso (area)
                if (thickerEyebrow === 'sinistro') {
                    feedback += 'Ed infine il sopracciglio sinistro √® pi√π spesso.';
                } else if (thickerEyebrow === 'destro') {
                    feedback += 'Ed infine il sopracciglio destro √® pi√π spesso.';
                }

                return feedback || null;
            };

            // ANALISI - Volto
            const originalAnalyzeFace = window.analyzeFace;
            window.analyzeFace = async function () {
                voiceAssistant.speakMessage('analysis_start');

                if (originalAnalyzeFace) {
                    try {
                        await originalAnalyzeFace();
                        voiceAssistant.speakMessage('analysis_complete');
                    } catch (error) {
                        voiceAssistant.speakMessage('analysis_failed');
                    }
                }
            };

            // CANVAS - Pulisci
            const originalClearCanvas = window.clearCanvas;
            window.clearCanvas = function () {
                if (originalClearCanvas) originalClearCanvas();
                voiceAssistant.speak('Canvas pulito');
            };

            // MISURAZIONI - Feedback vocale gestito direttamente in measurements.js
            console.log('‚úÖ Voice Assistant integrato con successo');
        }
    </script>

    <!-- Voice Widget Control Functions (Global) -->
    <script>
        // Variabili globali per il widget
        let isVoiceWidgetMinimized = false;
        let isVoiceListening = false;
        let isVoiceMuted = false;

        function toggleVoiceWidget() {
            isVoiceWidgetMinimized = !isVoiceWidgetMinimized;
            const widget = document.getElementById('voice-assistant-widget');
            const btn = document.querySelector('.voice-minimize-btn');

            if (widget && btn) {
                if (isVoiceWidgetMinimized) {
                    widget.classList.add('minimized');
                    btn.textContent = '+';
                } else {
                    widget.classList.remove('minimized');
                    btn.textContent = '‚àí';
                }
            }
        }

        function toggleVoiceListening() {
            if (typeof voiceAssistant === 'undefined') {
                console.error('voiceAssistant non disponibile');
                return;
            }

            // Supporta sia il widget originale che la sidebar
            const btn = document.getElementById('toggle-listening-btn-sidebar') || document.getElementById('toggle-listening-btn');
            const indicator = document.getElementById('status-indicator-sidebar') || document.getElementById('status-indicator');
            const statusText = document.getElementById('status-text-sidebar') || document.getElementById('status-text');
            const icon = document.getElementById('listening-icon-sidebar');
            const text = document.getElementById('listening-text-sidebar');

            isVoiceListening = voiceAssistant.toggleListening();

            if (btn) {
                if (isVoiceListening) {
                    btn.classList.add('active');
                    if (icon) icon.textContent = 'üî¥';
                    if (text) text.textContent = 'Stop Ascolto';
                    if (btn.querySelector('.btn-text')) btn.querySelector('.btn-text').textContent = 'Stop Ascolto';
                    if (btn.querySelector('.btn-icon')) btn.querySelector('.btn-icon').textContent = 'üî¥';
                    if (indicator) {
                        indicator.textContent = 'üî¥';
                        indicator.classList.add('listening');
                    }
                    if (statusText) statusText.textContent = 'In ascolto...';
                } else {
                    btn.classList.remove('active');
                    if (icon) icon.textContent = 'üé§';
                    if (text) text.textContent = 'Avvia Ascolto';
                    if (btn.querySelector('.btn-text')) btn.querySelector('.btn-text').textContent = 'Avvia Ascolto';
                    if (btn.querySelector('.btn-icon')) btn.querySelector('.btn-icon').textContent = 'üé§';
                    if (indicator) {
                        indicator.textContent = 'üü¢';
                        indicator.classList.remove('listening');
                        indicator.classList.add('active');
                    }
                    if (statusText) statusText.textContent = 'Pronto';
                }
            }
        }

        function toggleVoiceMute() {
            if (typeof voiceAssistant === 'undefined') {
                console.error('voiceAssistant non disponibile');
                return;
            }

            // Supporta sia il widget originale che la sidebar
            const btn = document.getElementById('toggle-mute-btn-sidebar') || document.getElementById('toggle-mute-btn');
            const icon = document.getElementById('mute-icon-sidebar');
            const text = document.getElementById('mute-text-sidebar');

            isVoiceMuted = voiceAssistant.toggleMute();

            if (btn) {
                if (isVoiceMuted) {
                    btn.classList.add('active');
                    if (icon) icon.textContent = 'üîá';
                    if (text) text.textContent = 'Unmute';
                    if (btn.querySelector('.btn-text')) btn.querySelector('.btn-text').textContent = 'Unmute';
                    if (btn.querySelector('.btn-icon')) btn.querySelector('.btn-icon').textContent = 'üîá';
                } else {
                    btn.classList.remove('active');
                    if (icon) icon.textContent = 'üîä';
                    if (text) text.textContent = 'Muto';
                    if (btn.querySelector('.btn-text')) btn.querySelector('.btn-text').textContent = 'Muto';
                    if (btn.querySelector('.btn-icon')) btn.querySelector('.btn-icon').textContent = 'üîä';
                }
            }
        }

        // Inizializza voice assistant nella sidebar
        window.addEventListener('load', async () => {
            // Aspetta che voiceAssistant sia disponibile
            let attempts = 0;
            const maxAttempts = 50;

            const waitForVoiceAssistant = () => {
                if (typeof voiceAssistant !== 'undefined') {
                    initVoiceSidebar();
                } else if (attempts < maxAttempts) {
                    attempts++;
                    setTimeout(waitForVoiceAssistant, 100);
                } else {
                    console.error('Voice Assistant non disponibile');
                    const indicator = document.getElementById('status-indicator-sidebar');
                    const statusText = document.getElementById('status-text-sidebar');
                    if (indicator) indicator.textContent = 'üî¥';
                    if (statusText) statusText.textContent = 'Non disponibile';
                }
            };

            waitForVoiceAssistant();
        });

        async function initVoiceSidebar() {
            const indicator = document.getElementById('status-indicator-sidebar');
            const statusText = document.getElementById('status-text-sidebar');

            try {
                const status = await voiceAssistant.getStatus();

                if (status && status.available) {
                    indicator.textContent = 'üü¢';
                    indicator.classList.add('active');
                    statusText.textContent = 'Connesso';
                } else {
                    indicator.textContent = 'üü¢';
                    indicator.classList.add('active');
                    statusText.textContent = 'Pronto';
                }
            } catch (error) {
                console.log('Voice status check fallito, ma TTS potrebbe funzionare');
                indicator.textContent = 'üü¢';
                indicator.classList.add('active');
                statusText.textContent = 'Pronto';
            }
        }
    </script>

</body>

</html>